
NB-IOT_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000458  00800100  00000f6a  00000ffe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f6a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000504  00800558  00800558  00001456  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001456  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001488  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000230  00000000  00000000  000014c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003491  00000000  00000000  000016f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001042  00000000  00000000  00004b85  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000015f8  00000000  00000000  00005bc7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000690  00000000  00000000  000071c0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000c9d  00000000  00000000  00007850  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000019f2  00000000  00000000  000084ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  00009edf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
   8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
   c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  30:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  48:	0c 94 22 07 	jmp	0xe44	; 0xe44 <__vector_18>
  4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__vector_21>
  58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  78:	0c 94 47 07 	jmp	0xe8e	; 0xe8e <__vector_30>
  7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	15 e0       	ldi	r17, 0x05	; 5
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ea e6       	ldi	r30, 0x6A	; 106
  a0:	ff e0       	ldi	r31, 0x0F	; 15
  a2:	02 c0       	rjmp	.+4      	; 0xa8 <__do_copy_data+0x10>
  a4:	05 90       	lpm	r0, Z+
  a6:	0d 92       	st	X+, r0
  a8:	a8 35       	cpi	r26, 0x58	; 88
  aa:	b1 07       	cpc	r27, r17
  ac:	d9 f7       	brne	.-10     	; 0xa4 <__do_copy_data+0xc>

000000ae <__do_clear_bss>:
  ae:	2a e0       	ldi	r18, 0x0A	; 10
  b0:	a8 e5       	ldi	r26, 0x58	; 88
  b2:	b5 e0       	ldi	r27, 0x05	; 5
  b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
  b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
  b8:	ac 35       	cpi	r26, 0x5C	; 92
  ba:	b2 07       	cpc	r27, r18
  bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
  be:	0e 94 91 00 	call	0x122	; 0x122 <main>
  c2:	0c 94 b3 07 	jmp	0xf66	; 0xf66 <_exit>

000000c6 <__bad_interrupt>:
  c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <__vector_21>:
	
	ADMUX =	(ADMUX&0xe0) | channel;			//不改变其他配置，并设置通道
	ADCSRA |= (1 << ADSC);					//启动转换
}

SIGNAL(ADC_vect){
  ca:	1f 92       	push	r1
  cc:	0f 92       	push	r0
  ce:	0f b6       	in	r0, 0x3f	; 63
  d0:	0f 92       	push	r0
  d2:	11 24       	eor	r1, r1
  d4:	2f 93       	push	r18
  d6:	8f 93       	push	r24
  d8:	9f 93       	push	r25
  da:	ef 93       	push	r30
  dc:	ff 93       	push	r31
	adc_channel_data_list[adc_interrupt_channel_cache] = (ADCL | ADCH << 8);
  de:	84 b1       	in	r24, 0x04	; 4
  e0:	25 b1       	in	r18, 0x05	; 5
  e2:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <__data_end>
  e6:	f0 e0       	ldi	r31, 0x00	; 0
  e8:	ee 0f       	add	r30, r30
  ea:	ff 1f       	adc	r31, r31
  ec:	e7 5a       	subi	r30, 0xA7	; 167
  ee:	fa 4f       	sbci	r31, 0xFA	; 250
  f0:	90 e0       	ldi	r25, 0x00	; 0
  f2:	92 2b       	or	r25, r18
  f4:	91 83       	std	Z+1, r25	; 0x01
  f6:	80 83       	st	Z, r24
  f8:	ff 91       	pop	r31
  fa:	ef 91       	pop	r30
  fc:	9f 91       	pop	r25
  fe:	8f 91       	pop	r24
 100:	2f 91       	pop	r18
 102:	0f 90       	pop	r0
 104:	0f be       	out	0x3f, r0	; 63
 106:	0f 90       	pop	r0
 108:	1f 90       	pop	r1
 10a:	18 95       	reti

0000010c <system_init>:
 */ 

#include "app.h"

void system_init(){
	cli();
 10c:	f8 94       	cli
	init_port();
 10e:	0e 94 95 06 	call	0xd2a	; 0xd2a <init_port>
	init_lcd();
 112:	0e 94 b6 05 	call	0xb6c	; 0xb6c <init_lcd>
	init_uart0();
 116:	0e 94 c5 06 	call	0xd8a	; 0xd8a <init_uart0>
	init_uart1();
 11a:	0e 94 d0 06 	call	0xda0	; 0xda0 <init_uart1>
	sei();
 11e:	78 94       	sei
 120:	08 95       	ret

00000122 <main>:
}

int main(void)
{
	system_init();
 122:	0e 94 86 00 	call	0x10c	; 0x10c <system_init>
	init_bc95();
 126:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <init_bc95>
	lcd_update_pure_ppm_display(sizeof(query_data_flag.message));
 12a:	8f ef       	ldi	r24, 0xFF	; 255
 12c:	90 e0       	ldi	r25, 0x00	; 0
 12e:	0e 94 78 06 	call	0xcf0	; 0xcf0 <lcd_update_pure_ppm_display>
 132:	ff cf       	rjmp	.-2      	; 0x132 <main+0x10>

00000134 <callback_get_imsi>:
	
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("--------------------------------------\r\n");
 134:	8e eb       	ldi	r24, 0xBE	; 190
 136:	91 e0       	ldi	r25, 0x01	; 1
 138:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
	uart0_send_string("bc95 get imsi is run ... \r\n");
 13c:	87 ee       	ldi	r24, 0xE7	; 231
 13e:	91 e0       	ldi	r25, 0x01	; 1
 140:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
	//判断获取到的imsi是否为15位如果不是则返回0
	if ((query_data_flag.info_offset_stop - query_data_flag.info_offset_start) != 15)
 144:	20 91 58 07 	lds	r18, 0x0758	; 0x800758 <query_data_flag+0x10e>
 148:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <query_data_flag+0x10d>
 14c:	82 2f       	mov	r24, r18
 14e:	90 e0       	ldi	r25, 0x00	; 0
 150:	8e 1b       	sub	r24, r30
 152:	91 09       	sbc	r25, r1
 154:	0f 97       	sbiw	r24, 0x0f	; 15
 156:	31 f0       	breq	.+12     	; 0x164 <callback_get_imsi+0x30>
	{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
		uart0_send_string("bc95 get imsi ---> NUMBER ERROR \r\n");
 158:	83 e0       	ldi	r24, 0x03	; 3
 15a:	92 e0       	ldi	r25, 0x02	; 2
 15c:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
		return 0;
 160:	80 e0       	ldi	r24, 0x00	; 0
 162:	08 95       	ret
	}
	//从起始偏移量开始复制到当前位置，即为imsi的数据,并返回
	for (unsigned int i = query_data_flag.info_offset_start ; i < query_data_flag.info_offset_stop ; i++)
 164:	f0 e0       	ldi	r31, 0x00	; 0
 166:	30 e0       	ldi	r19, 0x00	; 0
 168:	e2 17       	cp	r30, r18
 16a:	f3 07       	cpc	r31, r19
 16c:	58 f4       	brcc	.+22     	; 0x184 <callback_get_imsi+0x50>
 16e:	e6 5b       	subi	r30, 0xB6	; 182
 170:	f9 4f       	sbci	r31, 0xF9	; 249
 172:	ae e3       	ldi	r26, 0x3E	; 62
 174:	ba e0       	ldi	r27, 0x0A	; 10
 176:	26 5b       	subi	r18, 0xB6	; 182
 178:	39 4f       	sbci	r19, 0xF9	; 249
	{
		device_status_bc95.imsi[cache_count] = query_data_flag.message[i];
 17a:	81 91       	ld	r24, Z+
 17c:	8d 93       	st	X+, r24
		uart0_send_string("bc95 get imsi ---> NUMBER ERROR \r\n");
#endif
		return 0;
	}
	//从起始偏移量开始复制到当前位置，即为imsi的数据,并返回
	for (unsigned int i = query_data_flag.info_offset_start ; i < query_data_flag.info_offset_stop ; i++)
 17e:	e2 17       	cp	r30, r18
 180:	f3 07       	cpc	r31, r19
 182:	d9 f7       	brne	.-10     	; 0x17a <callback_get_imsi+0x46>

/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("bc95 get imsi ---> ");
 184:	86 e2       	ldi	r24, 0x26	; 38
 186:	92 e0       	ldi	r25, 0x02	; 2
 188:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
	uart0_send_string(device_status_bc95.imsi);
 18c:	8e e3       	ldi	r24, 0x3E	; 62
 18e:	9a e0       	ldi	r25, 0x0A	; 10
 190:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
	uart0_send_string(" \r\n");
 194:	8c ef       	ldi	r24, 0xFC	; 252
 196:	92 e0       	ldi	r25, 0x02	; 2
 198:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
	return 1;
 19c:	81 e0       	ldi	r24, 0x01	; 1
}
 19e:	08 95       	ret

000001a0 <callback_get_imei>:
* 功    能：解析bc95返回的数据，读取imei
* 入口参数：无
* 出口参数：无
* 返 回 值：unsigned char 获取是否成功，	1--->成功	0--->不成功
*-----------------------------------------------------------------------------*/
unsigned char callback_get_imei(){
 1a0:	cf 93       	push	r28
 1a2:	df 93       	push	r29
 1a4:	00 d0       	rcall	.+0      	; 0x1a6 <callback_get_imei+0x6>
 1a6:	00 d0       	rcall	.+0      	; 0x1a8 <callback_get_imei+0x8>
 1a8:	1f 92       	push	r1
 1aa:	cd b7       	in	r28, 0x3d	; 61
 1ac:	de b7       	in	r29, 0x3e	; 62
	unsigned char name[] = "CGSN";
 1ae:	85 e0       	ldi	r24, 0x05	; 5
 1b0:	ec ea       	ldi	r30, 0xAC	; 172
 1b2:	f2 e0       	ldi	r31, 0x02	; 2
 1b4:	de 01       	movw	r26, r28
 1b6:	11 96       	adiw	r26, 0x01	; 1
 1b8:	01 90       	ld	r0, Z+
 1ba:	0d 92       	st	X+, r0
 1bc:	8a 95       	dec	r24
 1be:	e1 f7       	brne	.-8      	; 0x1b8 <callback_get_imei+0x18>
	
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("--------------------------------------\r\n");
 1c0:	8e eb       	ldi	r24, 0xBE	; 190
 1c2:	91 e0       	ldi	r25, 0x01	; 1
 1c4:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
	uart0_send_string("bc95 get imei is run ... \r\n");
 1c8:	8a e3       	ldi	r24, 0x3A	; 58
 1ca:	92 e0       	ldi	r25, 0x02	; 2
 1cc:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif

	if (strstr(query_data_flag.message, name) != NULL)			//判断是否是需要的返回值
 1d0:	be 01       	movw	r22, r28
 1d2:	6f 5f       	subi	r22, 0xFF	; 255
 1d4:	7f 4f       	sbci	r23, 0xFF	; 255
 1d6:	8a e4       	ldi	r24, 0x4A	; 74
 1d8:	96 e0       	ldi	r25, 0x06	; 6
 1da:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 1de:	89 2b       	or	r24, r25
 1e0:	09 f4       	brne	.+2      	; 0x1e4 <callback_get_imei+0x44>
 1e2:	3f c0       	rjmp	.+126    	; 0x262 <callback_get_imei+0xc2>
	{
		//从”：“开始检查并存储数据到device_status_bc95.band	直到碰见“\r”数据结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
 1e4:	60 91 4b 07 	lds	r22, 0x074B	; 0x80074b <query_data_flag+0x101>
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	86 0f       	add	r24, r22
 1ec:	30 91 49 07 	lds	r19, 0x0749	; 0x800749 <query_data_flag+0xff>
 1f0:	83 17       	cp	r24, r19
 1f2:	70 f1       	brcs	.+92     	; 0x250 <callback_get_imei+0xb0>
 1f4:	3c c0       	rjmp	.+120    	; 0x26e <callback_get_imei+0xce>
		{
			if (query_data_flag.message[i] != '\r')
 1f6:	48 2f       	mov	r20, r24
 1f8:	50 e0       	ldi	r21, 0x00	; 0
 1fa:	fa 01       	movw	r30, r20
 1fc:	e6 5b       	subi	r30, 0xB6	; 182
 1fe:	f9 4f       	sbci	r31, 0xF9	; 249
 200:	90 81       	ld	r25, Z
 202:	9d 30       	cpi	r25, 0x0D	; 13
 204:	11 f4       	brne	.+4      	; 0x20a <callback_get_imei+0x6a>
 206:	0b c0       	rjmp	.+22     	; 0x21e <callback_get_imei+0x7e>
 208:	20 e0       	ldi	r18, 0x00	; 0
			{
				device_status_bc95.imei[cache_count] = query_data_flag.message[i];
 20a:	e2 2f       	mov	r30, r18
 20c:	f0 e0       	ldi	r31, 0x00	; 0
 20e:	e8 5d       	subi	r30, 0xD8	; 216
 210:	f5 4f       	sbci	r31, 0xF5	; 245
 212:	96 83       	std	Z+6, r25	; 0x06
				cache_count++;
 214:	2f 5f       	subi	r18, 0xFF	; 255
#endif

	if (strstr(query_data_flag.message, name) != NULL)			//判断是否是需要的返回值
	{
		//从”：“开始检查并存储数据到device_status_bc95.band	直到碰见“\r”数据结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
 216:	8f 5f       	subi	r24, 0xFF	; 255
 218:	83 17       	cp	r24, r19
 21a:	68 f3       	brcs	.-38     	; 0x1f6 <callback_get_imei+0x56>
 21c:	28 c0       	rjmp	.+80     	; 0x26e <callback_get_imei+0xce>
			if (query_data_flag.message[i] != '\r')
			{
				device_status_bc95.imei[cache_count] = query_data_flag.message[i];
				cache_count++;
			}else{
				if ((i - query_data_flag.colon_offset) != 16)
 21e:	46 1b       	sub	r20, r22
 220:	51 09       	sbc	r21, r1
 222:	40 31       	cpi	r20, 0x10	; 16
 224:	51 05       	cpc	r21, r1
 226:	31 f0       	breq	.+12     	; 0x234 <callback_get_imei+0x94>
				{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
				uart0_send_string("bc95 get imei ----> NUMBER ERROR \r\n");
 228:	86 e5       	ldi	r24, 0x56	; 86
 22a:	92 e0       	ldi	r25, 0x02	; 2
 22c:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
					return 0;
 230:	80 e0       	ldi	r24, 0x00	; 0
 232:	1d c0       	rjmp	.+58     	; 0x26e <callback_get_imei+0xce>
				}
/*--------------------------------------
			调试输出
--------------------------------------*/
#ifdef	DEBUG
				uart0_send_string("bc95 get imei ----> ");
 234:	8a e7       	ldi	r24, 0x7A	; 122
 236:	92 e0       	ldi	r25, 0x02	; 2
 238:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
				uart0_send_string(device_status_bc95.imei);
 23c:	8e e2       	ldi	r24, 0x2E	; 46
 23e:	9a e0       	ldi	r25, 0x0A	; 10
 240:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
				uart0_send_string(" \r\n");
 244:	8c ef       	ldi	r24, 0xFC	; 252
 246:	92 e0       	ldi	r25, 0x02	; 2
 248:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
				
				return 1;
 24c:	81 e0       	ldi	r24, 0x01	; 1
 24e:	0f c0       	rjmp	.+30     	; 0x26e <callback_get_imei+0xce>
	if (strstr(query_data_flag.message, name) != NULL)			//判断是否是需要的返回值
	{
		//从”：“开始检查并存储数据到device_status_bc95.band	直到碰见“\r”数据结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
		{
			if (query_data_flag.message[i] != '\r')
 250:	48 2f       	mov	r20, r24
 252:	50 e0       	ldi	r21, 0x00	; 0
 254:	fa 01       	movw	r30, r20
 256:	e6 5b       	subi	r30, 0xB6	; 182
 258:	f9 4f       	sbci	r31, 0xF9	; 249
 25a:	90 81       	ld	r25, Z
 25c:	9d 30       	cpi	r25, 0x0D	; 13
 25e:	a1 f6       	brne	.-88     	; 0x208 <callback_get_imei+0x68>
 260:	de cf       	rjmp	.-68     	; 0x21e <callback_get_imei+0x7e>
	}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
		uart0_send_string("bc95 get imei ----> ERROR \r\n");
 262:	8f e8       	ldi	r24, 0x8F	; 143
 264:	92 e0       	ldi	r25, 0x02	; 2
 266:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
		return 0;
 26a:	80 e0       	ldi	r24, 0x00	; 0
 26c:	00 c0       	rjmp	.+0      	; 0x26e <callback_get_imei+0xce>
	}
}
 26e:	0f 90       	pop	r0
 270:	0f 90       	pop	r0
 272:	0f 90       	pop	r0
 274:	0f 90       	pop	r0
 276:	0f 90       	pop	r0
 278:	df 91       	pop	r29
 27a:	cf 91       	pop	r28
 27c:	08 95       	ret

0000027e <callback_get_band>:
* 功    能：解析bc95返回的数据，读取band
* 入口参数：无
* 出口参数：无
* 返 回 值：unsigned char 获取是否成功，	1--->成功	0--->不成功
*-----------------------------------------------------------------------------*/
unsigned char callback_get_band(){
 27e:	cf 93       	push	r28
 280:	df 93       	push	r29
 282:	00 d0       	rcall	.+0      	; 0x284 <callback_get_band+0x6>
 284:	00 d0       	rcall	.+0      	; 0x286 <callback_get_band+0x8>
 286:	00 d0       	rcall	.+0      	; 0x288 <callback_get_band+0xa>
 288:	cd b7       	in	r28, 0x3d	; 61
 28a:	de b7       	in	r29, 0x3e	; 62
	unsigned char name[] = "NBAND";
 28c:	86 e0       	ldi	r24, 0x06	; 6
 28e:	e0 e0       	ldi	r30, 0x00	; 0
 290:	f3 e0       	ldi	r31, 0x03	; 3
 292:	de 01       	movw	r26, r28
 294:	11 96       	adiw	r26, 0x01	; 1
 296:	01 90       	ld	r0, Z+
 298:	0d 92       	st	X+, r0
 29a:	8a 95       	dec	r24
 29c:	e1 f7       	brne	.-8      	; 0x296 <callback_get_band+0x18>
	
/*--------------------------------------
调试输出
--------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("--------------------------------------\r\n");
 29e:	8e eb       	ldi	r24, 0xBE	; 190
 2a0:	91 e0       	ldi	r25, 0x01	; 1
 2a2:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
	uart0_send_string("bc95 get band is run ... \r\n");
 2a6:	81 eb       	ldi	r24, 0xB1	; 177
 2a8:	92 e0       	ldi	r25, 0x02	; 2
 2aa:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif

	if (strstr(query_data_flag.message, name) != NULL)			//判断是否是需要的返回值
 2ae:	be 01       	movw	r22, r28
 2b0:	6f 5f       	subi	r22, 0xFF	; 255
 2b2:	7f 4f       	sbci	r23, 0xFF	; 255
 2b4:	8a e4       	ldi	r24, 0x4A	; 74
 2b6:	96 e0       	ldi	r25, 0x06	; 6
 2b8:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 2bc:	89 2b       	or	r24, r25
 2be:	89 f1       	breq	.+98     	; 0x322 <callback_get_band+0xa4>
	{
		//从”：“开始检查并存储数据到device_status_bc95.band	直到碰见“\r”数据结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
 2c0:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <query_data_flag+0x101>
 2c4:	8f 5f       	subi	r24, 0xFF	; 255
 2c6:	30 91 49 07 	lds	r19, 0x0749	; 0x800749 <query_data_flag+0xff>
 2ca:	83 17       	cp	r24, r19
 2cc:	10 f1       	brcs	.+68     	; 0x312 <callback_get_band+0x94>
 2ce:	2f c0       	rjmp	.+94     	; 0x32e <callback_get_band+0xb0>
		{
			if (query_data_flag.message[i] != '\r')
 2d0:	e8 2f       	mov	r30, r24
 2d2:	f0 e0       	ldi	r31, 0x00	; 0
 2d4:	e6 5b       	subi	r30, 0xB6	; 182
 2d6:	f9 4f       	sbci	r31, 0xF9	; 249
 2d8:	90 81       	ld	r25, Z
 2da:	9d 30       	cpi	r25, 0x0D	; 13
 2dc:	11 f4       	brne	.+4      	; 0x2e2 <callback_get_band+0x64>
 2de:	0b c0       	rjmp	.+22     	; 0x2f6 <callback_get_band+0x78>
 2e0:	20 e0       	ldi	r18, 0x00	; 0
			{
				device_status_bc95.band[cache_count] = query_data_flag.message[i];
 2e2:	e2 2f       	mov	r30, r18
 2e4:	f0 e0       	ldi	r31, 0x00	; 0
 2e6:	e8 5d       	subi	r30, 0xD8	; 216
 2e8:	f5 4f       	sbci	r31, 0xF5	; 245
 2ea:	90 83       	st	Z, r25
				cache_count++;
 2ec:	2f 5f       	subi	r18, 0xFF	; 255
#endif

	if (strstr(query_data_flag.message, name) != NULL)			//判断是否是需要的返回值
	{
		//从”：“开始检查并存储数据到device_status_bc95.band	直到碰见“\r”数据结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
 2ee:	8f 5f       	subi	r24, 0xFF	; 255
 2f0:	83 17       	cp	r24, r19
 2f2:	70 f3       	brcs	.-36     	; 0x2d0 <callback_get_band+0x52>
 2f4:	1c c0       	rjmp	.+56     	; 0x32e <callback_get_band+0xb0>
			}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
				uart0_send_string("bc95 get band ----> ");
 2f6:	8d ec       	ldi	r24, 0xCD	; 205
 2f8:	92 e0       	ldi	r25, 0x02	; 2
 2fa:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
				uart0_send_string(device_status_bc95.band);
 2fe:	88 e2       	ldi	r24, 0x28	; 40
 300:	9a e0       	ldi	r25, 0x0A	; 10
 302:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
				uart0_send_string(" \r\n");
 306:	8c ef       	ldi	r24, 0xFC	; 252
 308:	92 e0       	ldi	r25, 0x02	; 2
 30a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
				
				return 1;
 30e:	81 e0       	ldi	r24, 0x01	; 1
 310:	0e c0       	rjmp	.+28     	; 0x32e <callback_get_band+0xb0>
	if (strstr(query_data_flag.message, name) != NULL)			//判断是否是需要的返回值
	{
		//从”：“开始检查并存储数据到device_status_bc95.band	直到碰见“\r”数据结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
		{
			if (query_data_flag.message[i] != '\r')
 312:	e8 2f       	mov	r30, r24
 314:	f0 e0       	ldi	r31, 0x00	; 0
 316:	e6 5b       	subi	r30, 0xB6	; 182
 318:	f9 4f       	sbci	r31, 0xF9	; 249
 31a:	90 81       	ld	r25, Z
 31c:	9d 30       	cpi	r25, 0x0D	; 13
 31e:	01 f7       	brne	.-64     	; 0x2e0 <callback_get_band+0x62>
 320:	ea cf       	rjmp	.-44     	; 0x2f6 <callback_get_band+0x78>
	}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
		uart0_send_string("bc95 get band ----> ERROR  \r\n");
 322:	82 ee       	ldi	r24, 0xE2	; 226
 324:	92 e0       	ldi	r25, 0x02	; 2
 326:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>

#endif
		return 0;
 32a:	80 e0       	ldi	r24, 0x00	; 0
 32c:	00 c0       	rjmp	.+0      	; 0x32e <callback_get_band+0xb0>
	}
}
 32e:	26 96       	adiw	r28, 0x06	; 6
 330:	0f b6       	in	r0, 0x3f	; 63
 332:	f8 94       	cli
 334:	de bf       	out	0x3e, r29	; 62
 336:	0f be       	out	0x3f, r0	; 63
 338:	cd bf       	out	0x3d, r28	; 61
 33a:	df 91       	pop	r29
 33c:	cf 91       	pop	r28
 33e:	08 95       	ret

00000340 <callback_get_csq>:
* 功    能：解析bc95返回的数据，读取csq信号强度
* 入口参数：无
* 出口参数：无
* 返 回 值：unsigned char 获取是否成功，	1--->成功	0--->不成功
*-----------------------------------------------------------------------------*/
unsigned char callback_get_csq(){
 340:	cf 93       	push	r28
 342:	df 93       	push	r29
 344:	00 d0       	rcall	.+0      	; 0x346 <callback_get_csq+0x6>
 346:	00 d0       	rcall	.+0      	; 0x348 <callback_get_csq+0x8>
 348:	cd b7       	in	r28, 0x3d	; 61
 34a:	de b7       	in	r29, 0x3e	; 62
	unsigned char name[] = "CSQ";
 34c:	83 e4       	ldi	r24, 0x43	; 67
 34e:	93 e5       	ldi	r25, 0x53	; 83
 350:	9a 83       	std	Y+2, r25	; 0x02
 352:	89 83       	std	Y+1, r24	; 0x01
 354:	81 e5       	ldi	r24, 0x51	; 81
 356:	90 e0       	ldi	r25, 0x00	; 0
 358:	9c 83       	std	Y+4, r25	; 0x04
 35a:	8b 83       	std	Y+3, r24	; 0x03
	
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
		uart0_send_string("--------------------------------------\r\n");
 35c:	8e eb       	ldi	r24, 0xBE	; 190
 35e:	91 e0       	ldi	r25, 0x01	; 1
 360:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
		uart0_send_string("bc95 get csq is run ... \r\n");
 364:	86 e0       	ldi	r24, 0x06	; 6
 366:	93 e0       	ldi	r25, 0x03	; 3
 368:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif

	if (strstr(query_data_flag.message, name) != NULL)	//判断是否存在返回的需要的相关数据
 36c:	be 01       	movw	r22, r28
 36e:	6f 5f       	subi	r22, 0xFF	; 255
 370:	7f 4f       	sbci	r23, 0xFF	; 255
 372:	8a e4       	ldi	r24, 0x4A	; 74
 374:	96 e0       	ldi	r25, 0x06	; 6
 376:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 37a:	89 2b       	or	r24, r25
 37c:	99 f1       	breq	.+102    	; 0x3e4 <callback_get_csq+0xa4>
	{
		//循环存储数据，从“：”开始为数据，碰到“，”即为结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
 37e:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <query_data_flag+0x101>
 382:	8f 5f       	subi	r24, 0xFF	; 255
 384:	30 91 49 07 	lds	r19, 0x0749	; 0x800749 <query_data_flag+0xff>
 388:	83 17       	cp	r24, r19
 38a:	20 f1       	brcs	.+72     	; 0x3d4 <callback_get_csq+0x94>
#ifdef	DEBUG
		uart0_send_string("bc95 get csq ----> ERROR \r\n");
#endif
		return 0;
	}
		return 0;
 38c:	80 e0       	ldi	r24, 0x00	; 0
 38e:	2f c0       	rjmp	.+94     	; 0x3ee <callback_get_csq+0xae>
	if (strstr(query_data_flag.message, name) != NULL)	//判断是否存在返回的需要的相关数据
	{
		//循环存储数据，从“：”开始为数据，碰到“，”即为结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
		{
			if (query_data_flag.message[i] != ',')		//如果碰不到“，”则继续接收
 390:	e8 2f       	mov	r30, r24
 392:	f0 e0       	ldi	r31, 0x00	; 0
 394:	e6 5b       	subi	r30, 0xB6	; 182
 396:	f9 4f       	sbci	r31, 0xF9	; 249
 398:	90 81       	ld	r25, Z
 39a:	9c 32       	cpi	r25, 0x2C	; 44
 39c:	11 f4       	brne	.+4      	; 0x3a2 <callback_get_csq+0x62>
 39e:	0c c0       	rjmp	.+24     	; 0x3b8 <callback_get_csq+0x78>
 3a0:	20 e0       	ldi	r18, 0x00	; 0
			{
				device_status_bc95.csq[cache_count] = query_data_flag.message[i];
 3a2:	e2 2f       	mov	r30, r18
 3a4:	f0 e0       	ldi	r31, 0x00	; 0
 3a6:	e8 5d       	subi	r30, 0xD8	; 216
 3a8:	f5 4f       	sbci	r31, 0xF5	; 245
 3aa:	93 83       	std	Z+3, r25	; 0x03
				cache_count++;						
 3ac:	2f 5f       	subi	r18, 0xFF	; 255
#endif

	if (strstr(query_data_flag.message, name) != NULL)	//判断是否存在返回的需要的相关数据
	{
		//循环存储数据，从“：”开始为数据，碰到“，”即为结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
 3ae:	8f 5f       	subi	r24, 0xFF	; 255
 3b0:	83 17       	cp	r24, r19
 3b2:	70 f3       	brcs	.-36     	; 0x390 <callback_get_csq+0x50>
#ifdef	DEBUG
		uart0_send_string("bc95 get csq ----> ERROR \r\n");
#endif
		return 0;
	}
		return 0;
 3b4:	80 e0       	ldi	r24, 0x00	; 0
 3b6:	1b c0       	rjmp	.+54     	; 0x3ee <callback_get_csq+0xae>
			}else{										//碰到“，”则返回1			
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
				uart0_send_string("bc95 get csq ----> ");
 3b8:	81 e2       	ldi	r24, 0x21	; 33
 3ba:	93 e0       	ldi	r25, 0x03	; 3
 3bc:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
				uart0_send_string(device_status_bc95.csq);
 3c0:	8b e2       	ldi	r24, 0x2B	; 43
 3c2:	9a e0       	ldi	r25, 0x0A	; 10
 3c4:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
				uart0_send_string(" \r\n");
 3c8:	8c ef       	ldi	r24, 0xFC	; 252
 3ca:	92 e0       	ldi	r25, 0x02	; 2
 3cc:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
				return 1;
 3d0:	81 e0       	ldi	r24, 0x01	; 1
 3d2:	0d c0       	rjmp	.+26     	; 0x3ee <callback_get_csq+0xae>
	if (strstr(query_data_flag.message, name) != NULL)	//判断是否存在返回的需要的相关数据
	{
		//循环存储数据，从“：”开始为数据，碰到“，”即为结束
		for (unsigned char i = query_data_flag.colon_offset+1 ; i < query_data_flag.message_length ; i++)
		{
			if (query_data_flag.message[i] != ',')		//如果碰不到“，”则继续接收
 3d4:	e8 2f       	mov	r30, r24
 3d6:	f0 e0       	ldi	r31, 0x00	; 0
 3d8:	e6 5b       	subi	r30, 0xB6	; 182
 3da:	f9 4f       	sbci	r31, 0xF9	; 249
 3dc:	90 81       	ld	r25, Z
 3de:	9c 32       	cpi	r25, 0x2C	; 44
 3e0:	f9 f6       	brne	.-66     	; 0x3a0 <callback_get_csq+0x60>
 3e2:	ea cf       	rjmp	.-44     	; 0x3b8 <callback_get_csq+0x78>
	}else{												//如果没有检测到相关的返回数据，则返回0
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
		uart0_send_string("bc95 get csq ----> ERROR \r\n");
 3e4:	85 e3       	ldi	r24, 0x35	; 53
 3e6:	93 e0       	ldi	r25, 0x03	; 3
 3e8:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
		return 0;
 3ec:	80 e0       	ldi	r24, 0x00	; 0
	}
		return 0;
}
 3ee:	0f 90       	pop	r0
 3f0:	0f 90       	pop	r0
 3f2:	0f 90       	pop	r0
 3f4:	0f 90       	pop	r0
 3f6:	df 91       	pop	r29
 3f8:	cf 91       	pop	r28
 3fa:	08 95       	ret

000003fc <callback_get_eps_status>:
* 功    能：解析bc95返回的数据，获取网络注册状态
* 入口参数：无
* 出口参数：无
* 返 回 值：unsigned char 获取是否成功，	1--->成功	0--->不成功
*-----------------------------------------------------------------------------*/
unsigned char callback_get_eps_status(){
 3fc:	0f 93       	push	r16
 3fe:	1f 93       	push	r17
 400:	cf 93       	push	r28
 402:	df 93       	push	r29
 404:	00 d0       	rcall	.+0      	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
 406:	00 d0       	rcall	.+0      	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
 408:	00 d0       	rcall	.+0      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
 40a:	cd b7       	in	r28, 0x3d	; 61
 40c:	de b7       	in	r29, 0x3e	; 62
	unsigned char name[] = "CEREG";
 40e:	86 e0       	ldi	r24, 0x06	; 6
 410:	ef eb       	ldi	r30, 0xBF	; 191
 412:	f3 e0       	ldi	r31, 0x03	; 3
 414:	de 01       	movw	r26, r28
 416:	11 96       	adiw	r26, 0x01	; 1
 418:	01 90       	ld	r0, Z+
 41a:	0d 92       	st	X+, r0
 41c:	8a 95       	dec	r24
 41e:	e1 f7       	brne	.-8      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
	
/*--------------------------------------
调试输出
--------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("--------------------------------------\r\n");
 420:	8e eb       	ldi	r24, 0xBE	; 190
 422:	91 e0       	ldi	r25, 0x01	; 1
 424:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
	uart0_send_string("bc95 get eps is run ... \r\n");
 428:	81 e5       	ldi	r24, 0x51	; 81
 42a:	93 e0       	ldi	r25, 0x03	; 3
 42c:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
	//判断是否是需要的返回值
	if (strstr(query_data_flag.message, name) != NULL)			
 430:	be 01       	movw	r22, r28
 432:	6f 5f       	subi	r22, 0xFF	; 255
 434:	7f 4f       	sbci	r23, 0xFF	; 255
 436:	8a e4       	ldi	r24, 0x4A	; 74
 438:	96 e0       	ldi	r25, 0x06	; 6
 43a:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 43e:	89 2b       	or	r24, r25
 440:	b9 f1       	breq	.+110    	; 0x4b0 <__LOCK_REGION_LENGTH__+0xb0>
	{
		//判断第一位是否位1个字符，如果是则继续判断第二个参数是否位1，如果不是则返回0 注册失败重新查询
		if ((query_data_flag.comma_offset[0] - query_data_flag.colon_offset) == 2)
 442:	80 91 4d 07 	lds	r24, 0x074D	; 0x80074d <query_data_flag+0x103>
 446:	90 e0       	ldi	r25, 0x00	; 0
 448:	20 91 4b 07 	lds	r18, 0x074B	; 0x80074b <query_data_flag+0x101>
 44c:	30 e0       	ldi	r19, 0x00	; 0
 44e:	ac 01       	movw	r20, r24
 450:	42 1b       	sub	r20, r18
 452:	53 0b       	sbc	r21, r19
 454:	42 30       	cpi	r20, 0x02	; 2
 456:	51 05       	cpc	r21, r1
 458:	89 f5       	brne	.+98     	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
		{
			if (query_data_flag.message[query_data_flag.comma_offset[0]+1] != '1')
 45a:	fc 01       	movw	r30, r24
 45c:	e6 5b       	subi	r30, 0xB6	; 182
 45e:	f9 4f       	sbci	r31, 0xF9	; 249
 460:	81 81       	ldd	r24, Z+1	; 0x01
 462:	81 33       	cpi	r24, 0x31	; 49
 464:	31 f0       	breq	.+12     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
			{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
				uart0_send_string("bc95 get eps ----> NUMBER ERROR \r\n");
 466:	8c e6       	ldi	r24, 0x6C	; 108
 468:	93 e0       	ldi	r25, 0x03	; 3
 46a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
				return 0;
 46e:	80 e0       	ldi	r24, 0x00	; 0
 470:	26 c0       	rjmp	.+76     	; 0x4be <__LOCK_REGION_LENGTH__+0xbe>
			}else{
				//从”：“开始存储数据到device_status_bc95.eps_status	只拷贝1位
				device_status_bc95.eps_status = query_data_flag.message[query_data_flag.colon_offset+1];
 472:	08 e2       	ldi	r16, 0x28	; 40
 474:	1a e0       	ldi	r17, 0x0A	; 10
 476:	f9 01       	movw	r30, r18
 478:	e6 5b       	subi	r30, 0xB6	; 182
 47a:	f9 4f       	sbci	r31, 0xF9	; 249
 47c:	81 81       	ldd	r24, Z+1	; 0x01
 47e:	f8 01       	movw	r30, r16
 480:	87 a3       	std	Z+39, r24	; 0x27
				//从”，“开始存储数据到device_status_bc95.eps_registered_status	只拷贝1位
				device_status_bc95.eps_registered_status = query_data_flag.message[query_data_flag.comma_offset[0]+1];
 482:	81 e3       	ldi	r24, 0x31	; 49
 484:	80 a7       	std	Z+40, r24	; 0x28
				
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
				uart0_send_string("bc95 get eps ----> ");
 486:	8f e8       	ldi	r24, 0x8F	; 143
 488:	93 e0       	ldi	r25, 0x03	; 3
 48a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
				uart0_send_byte(device_status_bc95.eps_status);
 48e:	f8 01       	movw	r30, r16
 490:	87 a1       	ldd	r24, Z+39	; 0x27
 492:	0e 94 e5 06 	call	0xdca	; 0xdca <uart0_send_byte>
				uart0_send_byte(',');
 496:	8c e2       	ldi	r24, 0x2C	; 44
 498:	0e 94 e5 06 	call	0xdca	; 0xdca <uart0_send_byte>
				uart0_send_byte(device_status_bc95.eps_registered_status);
 49c:	f8 01       	movw	r30, r16
 49e:	80 a5       	ldd	r24, Z+40	; 0x28
 4a0:	0e 94 e5 06 	call	0xdca	; 0xdca <uart0_send_byte>
				uart0_send_string(" \r\n");
 4a4:	8c ef       	ldi	r24, 0xFC	; 252
 4a6:	92 e0       	ldi	r25, 0x02	; 2
 4a8:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
				return 1;
 4ac:	81 e0       	ldi	r24, 0x01	; 1
 4ae:	07 c0       	rjmp	.+14     	; 0x4be <__LOCK_REGION_LENGTH__+0xbe>
	}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
		uart0_send_string("bc95 get eps ----> ERROR \r\n");
 4b0:	83 ea       	ldi	r24, 0xA3	; 163
 4b2:	93 e0       	ldi	r25, 0x03	; 3
 4b4:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
		return 0;
 4b8:	80 e0       	ldi	r24, 0x00	; 0
 4ba:	01 c0       	rjmp	.+2      	; 0x4be <__LOCK_REGION_LENGTH__+0xbe>
	}
	return 0;
 4bc:	80 e0       	ldi	r24, 0x00	; 0
}
 4be:	26 96       	adiw	r28, 0x06	; 6
 4c0:	0f b6       	in	r0, 0x3f	; 63
 4c2:	f8 94       	cli
 4c4:	de bf       	out	0x3e, r29	; 62
 4c6:	0f be       	out	0x3f, r0	; 63
 4c8:	cd bf       	out	0x3d, r28	; 61
 4ca:	df 91       	pop	r29
 4cc:	cf 91       	pop	r28
 4ce:	1f 91       	pop	r17
 4d0:	0f 91       	pop	r16
 4d2:	08 95       	ret

000004d4 <callback_get_profile_status>:
* 功    能：解析bc95返回的数据，获取上下文配置状态
* 入口参数：无
* 出口参数：无
* 返 回 值：unsigned char 获取是否成功，	1--->成功	0--->不成功
*-----------------------------------------------------------------------------*/
unsigned char callback_get_profile_status(){
 4d4:	0f 93       	push	r16
 4d6:	1f 93       	push	r17
 4d8:	cf 93       	push	r28
 4da:	df 93       	push	r29
 4dc:	00 d0       	rcall	.+0      	; 0x4de <callback_get_profile_status+0xa>
 4de:	00 d0       	rcall	.+0      	; 0x4e0 <callback_get_profile_status+0xc>
 4e0:	00 d0       	rcall	.+0      	; 0x4e2 <callback_get_profile_status+0xe>
 4e2:	cd b7       	in	r28, 0x3d	; 61
 4e4:	de b7       	in	r29, 0x3e	; 62
	unsigned char name[] = "CGATT";
 4e6:	86 e0       	ldi	r24, 0x06	; 6
 4e8:	e7 e3       	ldi	r30, 0x37	; 55
 4ea:	f4 e0       	ldi	r31, 0x04	; 4
 4ec:	de 01       	movw	r26, r28
 4ee:	11 96       	adiw	r26, 0x01	; 1
 4f0:	01 90       	ld	r0, Z+
 4f2:	0d 92       	st	X+, r0
 4f4:	8a 95       	dec	r24
 4f6:	e1 f7       	brne	.-8      	; 0x4f0 <callback_get_profile_status+0x1c>
	
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("--------------------------------------\r\n");
 4f8:	8e eb       	ldi	r24, 0xBE	; 190
 4fa:	91 e0       	ldi	r25, 0x01	; 1
 4fc:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
	uart0_send_string("bc95 get profile status is run ... \r\n");
 500:	85 ec       	ldi	r24, 0xC5	; 197
 502:	93 e0       	ldi	r25, 0x03	; 3
 504:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif

	if (strstr(query_data_flag.message, name) != NULL)			//判断是否是需要的返回值
 508:	be 01       	movw	r22, r28
 50a:	6f 5f       	subi	r22, 0xFF	; 255
 50c:	7f 4f       	sbci	r23, 0xFF	; 255
 50e:	8a e4       	ldi	r24, 0x4A	; 74
 510:	96 e0       	ldi	r25, 0x06	; 6
 512:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 516:	89 2b       	or	r24, r25
 518:	11 f1       	breq	.+68     	; 0x55e <callback_get_profile_status+0x8a>
	{
		if (query_data_flag.message[query_data_flag.colon_offset+1] == '1' || query_data_flag.message[query_data_flag.colon_offset+1] == 1)
 51a:	e0 91 4b 07 	lds	r30, 0x074B	; 0x80074b <query_data_flag+0x101>
 51e:	f0 e0       	ldi	r31, 0x00	; 0
 520:	e6 5b       	subi	r30, 0xB6	; 182
 522:	f9 4f       	sbci	r31, 0xF9	; 249
 524:	81 81       	ldd	r24, Z+1	; 0x01
 526:	81 33       	cpi	r24, 0x31	; 49
 528:	11 f0       	breq	.+4      	; 0x52e <callback_get_profile_status+0x5a>
 52a:	81 30       	cpi	r24, 0x01	; 1
 52c:	91 f4       	brne	.+36     	; 0x552 <callback_get_profile_status+0x7e>
		{
			device_status_bc95.profile_status = query_data_flag.message[query_data_flag.colon_offset+1];
 52e:	08 e2       	ldi	r16, 0x28	; 40
 530:	1a e0       	ldi	r17, 0x0A	; 10
 532:	f8 01       	movw	r30, r16
 534:	86 a3       	std	Z+38, r24	; 0x26
			
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
				uart0_send_string("bc95 get profile status ----> ");
 536:	8b ee       	ldi	r24, 0xEB	; 235
 538:	93 e0       	ldi	r25, 0x03	; 3
 53a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
				uart0_send_byte(device_status_bc95.profile_status);
 53e:	f8 01       	movw	r30, r16
 540:	86 a1       	ldd	r24, Z+38	; 0x26
 542:	0e 94 e5 06 	call	0xdca	; 0xdca <uart0_send_byte>
				uart0_send_string(" \r\n");
 546:	8c ef       	ldi	r24, 0xFC	; 252
 548:	92 e0       	ldi	r25, 0x02	; 2
 54a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
			return 1;
 54e:	81 e0       	ldi	r24, 0x01	; 1
 550:	13 c0       	rjmp	.+38     	; 0x578 <callback_get_profile_status+0xa4>
		}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
				uart0_send_string("bc95 get profile status ----> ERROR \r\n");
 552:	8a e0       	ldi	r24, 0x0A	; 10
 554:	94 e0       	ldi	r25, 0x04	; 4
 556:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
			return 0;
 55a:	80 e0       	ldi	r24, 0x00	; 0
 55c:	0d c0       	rjmp	.+26     	; 0x578 <callback_get_profile_status+0xa4>
	}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
		uart0_send_string("bc95 get profile status ----> ");
 55e:	8b ee       	ldi	r24, 0xEB	; 235
 560:	93 e0       	ldi	r25, 0x03	; 3
 562:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
		uart0_send_string("ERROR");
 566:	81 e3       	ldi	r24, 0x31	; 49
 568:	94 e0       	ldi	r25, 0x04	; 4
 56a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
		uart0_send_string(" \r\n");
 56e:	8c ef       	ldi	r24, 0xFC	; 252
 570:	92 e0       	ldi	r25, 0x02	; 2
 572:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
		return 0;
 576:	80 e0       	ldi	r24, 0x00	; 0
	}
}
 578:	26 96       	adiw	r28, 0x06	; 6
 57a:	0f b6       	in	r0, 0x3f	; 63
 57c:	f8 94       	cli
 57e:	de bf       	out	0x3e, r29	; 62
 580:	0f be       	out	0x3f, r0	; 63
 582:	cd bf       	out	0x3d, r28	; 61
 584:	df 91       	pop	r29
 586:	cf 91       	pop	r28
 588:	1f 91       	pop	r17
 58a:	0f 91       	pop	r16
 58c:	08 95       	ret

0000058e <callback_get_plmn>:

unsigned char callback_get_plmn(){
 58e:	cf 93       	push	r28
 590:	df 93       	push	r29
 592:	00 d0       	rcall	.+0      	; 0x594 <callback_get_plmn+0x6>
 594:	00 d0       	rcall	.+0      	; 0x596 <callback_get_plmn+0x8>
 596:	1f 92       	push	r1
 598:	cd b7       	in	r28, 0x3d	; 61
 59a:	de b7       	in	r29, 0x3e	; 62
		unsigned char name[] = "COPS";
 59c:	85 e0       	ldi	r24, 0x05	; 5
 59e:	eb e8       	ldi	r30, 0x8B	; 139
 5a0:	f4 e0       	ldi	r31, 0x04	; 4
 5a2:	de 01       	movw	r26, r28
 5a4:	11 96       	adiw	r26, 0x01	; 1
 5a6:	01 90       	ld	r0, Z+
 5a8:	0d 92       	st	X+, r0
 5aa:	8a 95       	dec	r24
 5ac:	e1 f7       	brne	.-8      	; 0x5a6 <callback_get_plmn+0x18>
	
/*--------------------------------------
调试输出
--------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("--------------------------------------\r\n");
 5ae:	8e eb       	ldi	r24, 0xBE	; 190
 5b0:	91 e0       	ldi	r25, 0x01	; 1
 5b2:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
	uart0_send_string("bc95 get plmn is run ... \r\n");
 5b6:	8d e3       	ldi	r24, 0x3D	; 61
 5b8:	94 e0       	ldi	r25, 0x04	; 4
 5ba:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
	//判断是否是需要的返回值
	if (strstr(query_data_flag.message, name) != NULL)			
 5be:	be 01       	movw	r22, r28
 5c0:	6f 5f       	subi	r22, 0xFF	; 255
 5c2:	7f 4f       	sbci	r23, 0xFF	; 255
 5c4:	8a e4       	ldi	r24, 0x4A	; 74
 5c6:	96 e0       	ldi	r25, 0x06	; 6
 5c8:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 5cc:	89 2b       	or	r24, r25
 5ce:	09 f4       	brne	.+2      	; 0x5d2 <callback_get_plmn+0x44>
 5d0:	64 c0       	rjmp	.+200    	; 0x69a <callback_get_plmn+0x10c>
	{
		if (query_data_flag.comma_offset_number != 2)
 5d2:	80 91 4c 07 	lds	r24, 0x074C	; 0x80074c <query_data_flag+0x102>
 5d6:	82 30       	cpi	r24, 0x02	; 2
 5d8:	31 f0       	breq	.+12     	; 0x5e6 <callback_get_plmn+0x58>
		{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
			uart0_send_string("bc95 get plmn ----> ERROR \r\n");
 5da:	89 e5       	ldi	r24, 0x59	; 89
 5dc:	94 e0       	ldi	r25, 0x04	; 4
 5de:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
			return 0;
 5e2:	80 e0       	ldi	r24, 0x00	; 0
 5e4:	61 c0       	rjmp	.+194    	; 0x6a8 <callback_get_plmn+0x11a>
		}
		//判断第一位是否位1个字符，如果是则继续判断第二个参数是否为1个字符，如果不是则返回0 注册失败重新查询
		if ((query_data_flag.comma_offset[0] - query_data_flag.colon_offset) == 2)
 5e6:	20 91 4d 07 	lds	r18, 0x074D	; 0x80074d <query_data_flag+0x103>
 5ea:	30 e0       	ldi	r19, 0x00	; 0
 5ec:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <query_data_flag+0x101>
 5f0:	90 e0       	ldi	r25, 0x00	; 0
 5f2:	a9 01       	movw	r20, r18
 5f4:	48 1b       	sub	r20, r24
 5f6:	59 0b       	sbc	r21, r25
 5f8:	42 30       	cpi	r20, 0x02	; 2
 5fa:	51 05       	cpc	r21, r1
 5fc:	09 f0       	breq	.+2      	; 0x600 <callback_get_plmn+0x72>
 5fe:	53 c0       	rjmp	.+166    	; 0x6a6 <callback_get_plmn+0x118>
		{
			if ((query_data_flag.comma_offset[1] - query_data_flag.comma_offset[0]) == 2)
 600:	e0 91 4e 07 	lds	r30, 0x074E	; 0x80074e <query_data_flag+0x104>
 604:	4e 2f       	mov	r20, r30
 606:	50 e0       	ldi	r21, 0x00	; 0
 608:	ba 01       	movw	r22, r20
 60a:	62 1b       	sub	r22, r18
 60c:	73 0b       	sbc	r23, r19
 60e:	62 30       	cpi	r22, 0x02	; 2
 610:	71 05       	cpc	r23, r1
 612:	e9 f5       	brne	.+122    	; 0x68e <callback_get_plmn+0x100>
			{
				//存储plmn状态
				device_status_bc95.plmn_status = query_data_flag.message[query_data_flag.colon_offset+1];
 614:	dc 01       	movw	r26, r24
 616:	a6 5b       	subi	r26, 0xB6	; 182
 618:	b9 4f       	sbci	r27, 0xF9	; 249
 61a:	11 96       	adiw	r26, 0x01	; 1
 61c:	8c 91       	ld	r24, X
 61e:	80 93 51 0a 	sts	0x0A51, r24	; 0x800a51 <device_status_bc95+0x29>
				
				//循环存储gsm位置区域识别号，碰到‘\r’即为结束，并返回
				for (unsigned int i = query_data_flag.comma_offset[1]; i < query_data_flag.message_length ; i++)
 622:	fa 01       	movw	r30, r20
 624:	20 91 49 07 	lds	r18, 0x0749	; 0x800749 <query_data_flag+0xff>
 628:	30 e0       	ldi	r19, 0x00	; 0
 62a:	e2 17       	cp	r30, r18
 62c:	f3 07       	cpc	r31, r19
 62e:	20 f1       	brcs	.+72     	; 0x678 <callback_get_plmn+0xea>
#ifdef	DEBUG
		uart0_send_string("bc95 get plmn ----> ERROR \r\n");
#endif
		return 0;
	}
	return 0;
 630:	80 e0       	ldi	r24, 0x00	; 0
 632:	3a c0       	rjmp	.+116    	; 0x6a8 <callback_get_plmn+0x11a>
				device_status_bc95.plmn_status = query_data_flag.message[query_data_flag.colon_offset+1];
				
				//循环存储gsm位置区域识别号，碰到‘\r’即为结束，并返回
				for (unsigned int i = query_data_flag.comma_offset[1]; i < query_data_flag.message_length ; i++)
				{
					if (query_data_flag.message[i] != '\r')
 634:	81 91       	ld	r24, Z+
 636:	8d 30       	cpi	r24, 0x0D	; 13
 638:	41 f0       	breq	.+16     	; 0x64a <callback_get_plmn+0xbc>
 63a:	98 2f       	mov	r25, r24
			{
				//存储plmn状态
				device_status_bc95.plmn_status = query_data_flag.message[query_data_flag.colon_offset+1];
				
				//循环存储gsm位置区域识别号，碰到‘\r’即为结束，并返回
				for (unsigned int i = query_data_flag.comma_offset[1]; i < query_data_flag.message_length ; i++)
 63c:	e2 17       	cp	r30, r18
 63e:	f3 07       	cpc	r31, r19
 640:	c9 f7       	brne	.-14     	; 0x634 <callback_get_plmn+0xa6>
 642:	90 93 52 0a 	sts	0x0A52, r25	; 0x800a52 <device_status_bc95+0x2a>
#ifdef	DEBUG
		uart0_send_string("bc95 get plmn ----> ERROR \r\n");
#endif
		return 0;
	}
	return 0;
 646:	80 e0       	ldi	r24, 0x00	; 0
 648:	2f c0       	rjmp	.+94     	; 0x6a8 <callback_get_plmn+0x11a>
 64a:	90 93 52 0a 	sts	0x0A52, r25	; 0x800a52 <device_status_bc95+0x2a>
					}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
			uart0_send_string("bc95 get plmn ----> ");
 64e:	86 e7       	ldi	r24, 0x76	; 118
 650:	94 e0       	ldi	r25, 0x04	; 4
 652:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
			uart0_send_byte(device_status_bc95.plmn_status);
 656:	80 91 51 0a 	lds	r24, 0x0A51	; 0x800a51 <device_status_bc95+0x29>
 65a:	0e 94 e5 06 	call	0xdca	; 0xdca <uart0_send_byte>
			uart0_send_byte(',');
 65e:	8c e2       	ldi	r24, 0x2C	; 44
 660:	0e 94 e5 06 	call	0xdca	; 0xdca <uart0_send_byte>
			uart0_send_string(device_status_bc95.gsm_location_number);
 664:	82 e5       	ldi	r24, 0x52	; 82
 666:	9a e0       	ldi	r25, 0x0A	; 10
 668:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
			uart0_send_string(" \r\n");
 66c:	8c ef       	ldi	r24, 0xFC	; 252
 66e:	92 e0       	ldi	r25, 0x02	; 2
 670:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
						return 1;
 674:	81 e0       	ldi	r24, 0x01	; 1
 676:	18 c0       	rjmp	.+48     	; 0x6a8 <callback_get_plmn+0x11a>
				device_status_bc95.plmn_status = query_data_flag.message[query_data_flag.colon_offset+1];
				
				//循环存储gsm位置区域识别号，碰到‘\r’即为结束，并返回
				for (unsigned int i = query_data_flag.comma_offset[1]; i < query_data_flag.message_length ; i++)
				{
					if (query_data_flag.message[i] != '\r')
 678:	df 01       	movw	r26, r30
 67a:	a6 5b       	subi	r26, 0xB6	; 182
 67c:	b9 4f       	sbci	r27, 0xF9	; 249
 67e:	9c 91       	ld	r25, X
 680:	9d 30       	cpi	r25, 0x0D	; 13
 682:	29 f3       	breq	.-54     	; 0x64e <callback_get_plmn+0xc0>
 684:	e5 5b       	subi	r30, 0xB5	; 181
 686:	f9 4f       	sbci	r31, 0xF9	; 249
 688:	26 5b       	subi	r18, 0xB6	; 182
 68a:	39 4f       	sbci	r19, 0xF9	; 249
 68c:	d7 cf       	rjmp	.-82     	; 0x63c <callback_get_plmn+0xae>
			}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
			uart0_send_string("bc95 get plmn ----> ERROR \r\n");
 68e:	89 e5       	ldi	r24, 0x59	; 89
 690:	94 e0       	ldi	r25, 0x04	; 4
 692:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#ifdef	DEBUG
		uart0_send_string("bc95 get plmn ----> ERROR \r\n");
#endif
		return 0;
	}
	return 0;
 696:	80 e0       	ldi	r24, 0x00	; 0
 698:	07 c0       	rjmp	.+14     	; 0x6a8 <callback_get_plmn+0x11a>
	}else{
/*--------------------------------------
				调试输出
--------------------------------------*/
#ifdef	DEBUG
		uart0_send_string("bc95 get plmn ----> ERROR \r\n");
 69a:	89 e5       	ldi	r24, 0x59	; 89
 69c:	94 e0       	ldi	r25, 0x04	; 4
 69e:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
		return 0;
 6a2:	80 e0       	ldi	r24, 0x00	; 0
 6a4:	01 c0       	rjmp	.+2      	; 0x6a8 <callback_get_plmn+0x11a>
	}
	return 0;
 6a6:	80 e0       	ldi	r24, 0x00	; 0
}
 6a8:	0f 90       	pop	r0
 6aa:	0f 90       	pop	r0
 6ac:	0f 90       	pop	r0
 6ae:	0f 90       	pop	r0
 6b0:	0f 90       	pop	r0
 6b2:	df 91       	pop	r29
 6b4:	cf 91       	pop	r28
 6b6:	08 95       	ret

000006b8 <type_set_process>:
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
unsigned char type_set_process(){
	unsigned char uart1_rx_array1[] = "\r\nOK\r\n";
	strcpy(query_data_flag.message, uart1_rx_data.message);
 6b8:	6f e5       	ldi	r22, 0x5F	; 95
 6ba:	79 e0       	ldi	r23, 0x09	; 9
 6bc:	8a e4       	ldi	r24, 0x4A	; 74
 6be:	96 e0       	ldi	r25, 0x06	; 6
 6c0:	0e 94 92 07 	call	0xf24	; 0xf24 <strcpy>
	uart1_rx_array_set_empty();
 6c4:	0e 94 1a 07 	call	0xe34	; 0xe34 <uart1_rx_array_set_empty>
	query_data_flag.message_length = strlen(query_data_flag.message);
 6c8:	ea e4       	ldi	r30, 0x4A	; 74
 6ca:	f6 e0       	ldi	r31, 0x06	; 6
 6cc:	01 90       	ld	r0, Z+
 6ce:	00 20       	and	r0, r0
 6d0:	e9 f7       	brne	.-6      	; 0x6cc <type_set_process+0x14>
 6d2:	31 97       	sbiw	r30, 0x01	; 1
 6d4:	ea 54       	subi	r30, 0x4A	; 74
 6d6:	f6 40       	sbci	r31, 0x06	; 6
 6d8:	e0 93 49 07 	sts	0x0749, r30	; 0x800749 <query_data_flag+0xff>
/*--------------------------------------
			调试输出
--------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("bc95 set process is run ... \r\n");
 6dc:	80 e9       	ldi	r24, 0x90	; 144
 6de:	94 e0       	ldi	r25, 0x04	; 4
 6e0:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
	
	if (strstr(query_data_flag.message, bc95_response_ok) != NULL)
 6e4:	61 e5       	ldi	r22, 0x51	; 81
 6e6:	75 e0       	ldi	r23, 0x05	; 5
 6e8:	8a e4       	ldi	r24, 0x4A	; 74
 6ea:	96 e0       	ldi	r25, 0x06	; 6
 6ec:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 6f0:	89 2b       	or	r24, r25
 6f2:	21 f0       	breq	.+8      	; 0x6fc <type_set_process+0x44>
	{
		
		uart1_rx_array_set_empty();
 6f4:	0e 94 1a 07 	call	0xe34	; 0xe34 <uart1_rx_array_set_empty>
		return 1;
 6f8:	81 e0       	ldi	r24, 0x01	; 1
 6fa:	08 95       	ret
	}else if (strstr(query_data_flag.message, bc95_response_error) != NULL)
 6fc:	6b e4       	ldi	r22, 0x4B	; 75
 6fe:	75 e0       	ldi	r23, 0x05	; 5
 700:	8a e4       	ldi	r24, 0x4A	; 74
 702:	96 e0       	ldi	r25, 0x06	; 6
 704:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 708:	89 2b       	or	r24, r25
 70a:	21 f4       	brne	.+8      	; 0x714 <type_set_process+0x5c>
	{
		
		return 0;
	}
	uart1_rx_array_set_empty();
 70c:	0e 94 1a 07 	call	0xe34	; 0xe34 <uart1_rx_array_set_empty>
	return 0;
 710:	80 e0       	ldi	r24, 0x00	; 0
 712:	08 95       	ret
		uart1_rx_array_set_empty();
		return 1;
	}else if (strstr(query_data_flag.message, bc95_response_error) != NULL)
	{
		
		return 0;
 714:	80 e0       	ldi	r24, 0x00	; 0
	}
	uart1_rx_array_set_empty();
	return 0;
}
 716:	08 95       	ret

00000718 <type_info_process>:
* 功    能：类型为info的数据处理
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
unsigned char type_info_process(unsigned char init_command_number){
 718:	cf 93       	push	r28
 71a:	c8 2f       	mov	r28, r24
	unsigned char test[] = "\r\n460111176388046\r\n\r\nOK\r\n";
	//strcpy(query_data_flag.message, uart1_rx_array);
	strcpy(query_data_flag.message, uart1_rx_data.message);
 71c:	6f e5       	ldi	r22, 0x5F	; 95
 71e:	79 e0       	ldi	r23, 0x09	; 9
 720:	8a e4       	ldi	r24, 0x4A	; 74
 722:	96 e0       	ldi	r25, 0x06	; 6
 724:	0e 94 92 07 	call	0xf24	; 0xf24 <strcpy>
	uart1_rx_array_set_empty();
 728:	0e 94 1a 07 	call	0xe34	; 0xe34 <uart1_rx_array_set_empty>
	query_data_flag.message_length = strlen(query_data_flag.message);
 72c:	ea e4       	ldi	r30, 0x4A	; 74
 72e:	f6 e0       	ldi	r31, 0x06	; 6
 730:	01 90       	ld	r0, Z+
 732:	00 20       	and	r0, r0
 734:	e9 f7       	brne	.-6      	; 0x730 <type_info_process+0x18>
 736:	31 97       	sbiw	r30, 0x01	; 1
 738:	ea 54       	subi	r30, 0x4A	; 74
 73a:	f6 40       	sbci	r31, 0x06	; 6
 73c:	e0 93 49 07 	sts	0x0749, r30	; 0x800749 <query_data_flag+0xff>
	unsigned char cache_count = 0;
	/*--------------------------------------
					调试输出
    --------------------------------------*/
#ifdef	DEBUG
	uart0_send_string("bc95 info process is run ... \r\n");
 740:	8f ea       	ldi	r24, 0xAF	; 175
 742:	94 e0       	ldi	r25, 0x04	; 4
 744:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
#endif
	
	if (strstr(query_data_flag.message, bc95_response_ok) != NULL)
 748:	61 e5       	ldi	r22, 0x51	; 81
 74a:	75 e0       	ldi	r23, 0x05	; 5
 74c:	8a e4       	ldi	r24, 0x4A	; 74
 74e:	96 e0       	ldi	r25, 0x06	; 6
 750:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 754:	89 2b       	or	r24, r25
 756:	d1 f1       	breq	.+116    	; 0x7cc <type_info_process+0xb4>
	{
		//循环遍历信息
		for (unsigned int i = 0 ; i < query_data_flag.message_length ; i ++){
 758:	40 91 49 07 	lds	r20, 0x0749	; 0x800749 <query_data_flag+0xff>
 75c:	50 e0       	ldi	r21, 0x00	; 0
 75e:	41 15       	cp	r20, r1
 760:	51 05       	cpc	r21, r1
 762:	b1 f1       	breq	.+108    	; 0x7d0 <type_info_process+0xb8>
 764:	70 91 57 07 	lds	r23, 0x0757	; 0x800757 <query_data_flag+0x10d>
 768:	80 e0       	ldi	r24, 0x00	; 0
 76a:	90 e0       	ldi	r25, 0x00	; 0
			if (query_data_flag.message[i] == '\r')
 76c:	fc 01       	movw	r30, r24
 76e:	e6 5b       	subi	r30, 0xB6	; 182
 770:	f9 4f       	sbci	r31, 0xF9	; 249
 772:	20 81       	ld	r18, Z
 774:	2d 30       	cpi	r18, 0x0D	; 13
 776:	11 f5       	brne	.+68     	; 0x7bc <type_info_process+0xa4>
			{
				//如果已经找到数据开头，则再次检测到”\r“为结束
				if (query_data_flag.info_offset_start != 0)		
 778:	77 23       	and	r23, r23
 77a:	a1 f0       	breq	.+40     	; 0x7a4 <type_info_process+0x8c>
 77c:	70 93 57 07 	sts	0x0757, r23	; 0x800757 <query_data_flag+0x10d>
				{
					query_data_flag.info_offset_stop = i;
 780:	80 93 58 07 	sts	0x0758, r24	; 0x800758 <query_data_flag+0x10e>
					return init_command[init_command_number].callback_function();
 784:	8c 2f       	mov	r24, r28
 786:	90 e0       	ldi	r25, 0x00	; 0
 788:	fc 01       	movw	r30, r24
 78a:	ee 0f       	add	r30, r30
 78c:	ff 1f       	adc	r31, r31
 78e:	e8 0f       	add	r30, r24
 790:	f9 1f       	adc	r31, r25
 792:	ee 0f       	add	r30, r30
 794:	ff 1f       	adc	r31, r31
 796:	e0 50       	subi	r30, 0x00	; 0
 798:	ff 4f       	sbci	r31, 0xFF	; 255
 79a:	04 80       	ldd	r0, Z+4	; 0x04
 79c:	f5 81       	ldd	r31, Z+5	; 0x05
 79e:	e0 2d       	mov	r30, r0
 7a0:	09 95       	icall
 7a2:	17 c0       	rjmp	.+46     	; 0x7d2 <type_info_process+0xba>
				}
				//如果检测到”\r“则直接看下一位是否为”\n“如果是则直接跳过/n到数据位
				if (query_data_flag.message[i+1] == '\n')		
 7a4:	9c 01       	movw	r18, r24
 7a6:	2f 5f       	subi	r18, 0xFF	; 255
 7a8:	3f 4f       	sbci	r19, 0xFF	; 255
 7aa:	f9 01       	movw	r30, r18
 7ac:	e6 5b       	subi	r30, 0xB6	; 182
 7ae:	f9 4f       	sbci	r31, 0xF9	; 249
 7b0:	60 81       	ld	r22, Z
 7b2:	6a 30       	cpi	r22, 0x0A	; 10
 7b4:	19 f4       	brne	.+6      	; 0x7bc <type_info_process+0xa4>
				{
					i++;
					//设置信息开始位置偏移量
					query_data_flag.info_offset_start = i+1;
 7b6:	71 e0       	ldi	r23, 0x01	; 1
 7b8:	72 0f       	add	r23, r18
					return init_command[init_command_number].callback_function();
				}
				//如果检测到”\r“则直接看下一位是否为”\n“如果是则直接跳过/n到数据位
				if (query_data_flag.message[i+1] == '\n')		
				{
					i++;
 7ba:	c9 01       	movw	r24, r18
#endif
	
	if (strstr(query_data_flag.message, bc95_response_ok) != NULL)
	{
		//循环遍历信息
		for (unsigned int i = 0 ; i < query_data_flag.message_length ; i ++){
 7bc:	01 96       	adiw	r24, 0x01	; 1
 7be:	84 17       	cp	r24, r20
 7c0:	95 07       	cpc	r25, r21
 7c2:	a0 f2       	brcs	.-88     	; 0x76c <type_info_process+0x54>
 7c4:	70 93 57 07 	sts	0x0757, r23	; 0x800757 <query_data_flag+0x10d>
	{
		return 0;
	}else{
		return 0;
	}
	return 0;
 7c8:	80 e0       	ldi	r24, 0x00	; 0
 7ca:	03 c0       	rjmp	.+6      	; 0x7d2 <type_info_process+0xba>
			}
		}
	}	//判断是否出错，
	else if (strstr(query_data_flag.message, bc95_response_error) != NULL)
	{
		return 0;
 7cc:	80 e0       	ldi	r24, 0x00	; 0
 7ce:	01 c0       	rjmp	.+2      	; 0x7d2 <type_info_process+0xba>
	}else{
		return 0;
	}
	return 0;
 7d0:	80 e0       	ldi	r24, 0x00	; 0
}
 7d2:	cf 91       	pop	r28
 7d4:	08 95       	ret

000007d6 <type_query_process>:
* 出口参数：无

* 返 回 值：unsigned char						1--->成功	0--->不成功
*-----------------------------------------------------------------------------*/

unsigned char type_query_process(unsigned char callback_function_number){
 7d6:	cf 93       	push	r28
 7d8:	c8 2f       	mov	r28, r24
	//测试数据
	//unsigned char uart1_rx_array1[] = "\r\n+NBAND:5\r\n\r\nOK\r\n";
	//unsigned char uart1_rx_array1[] = "\r\n+CSQ:12,99\r\n\r\nOK\r\n";
	//unsigned char uart1_rx_array1[] = "\r\n+CGSN:863703030636570\r\n\r\nOK\r\n";
	//unsigned char uart1_rx_array1[] = "\r\n+CGATT:1\r\n\r\nOK\r\n";
	strcpy(query_data_flag.message, uart1_rx_data.message);	//复制串口数据
 7da:	6f e5       	ldi	r22, 0x5F	; 95
 7dc:	79 e0       	ldi	r23, 0x09	; 9
 7de:	8a e4       	ldi	r24, 0x4A	; 74
 7e0:	96 e0       	ldi	r25, 0x06	; 6
 7e2:	0e 94 92 07 	call	0xf24	; 0xf24 <strcpy>
	uart1_rx_array_set_empty();							//清空串口数据用于接收
 7e6:	0e 94 1a 07 	call	0xe34	; 0xe34 <uart1_rx_array_set_empty>
	
	uart0_send_string(query_data_flag.message);
 7ea:	8a e4       	ldi	r24, 0x4A	; 74
 7ec:	96 e0       	ldi	r25, 0x06	; 6
 7ee:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
													
	query_data_flag.comma_offset_number = 0;									//初始化逗号记录，记录有多少个逗号，就有+1个数据
 7f2:	10 92 4c 07 	sts	0x074C, r1	; 0x80074c <query_data_flag+0x102>
	
	if (strstr(query_data_flag.message, bc95_response_ok)!= NULL && strstr(query_data_flag.message, "+") != NULL && strstr(query_data_flag.message, ":") != NULL)
 7f6:	61 e5       	ldi	r22, 0x51	; 81
 7f8:	75 e0       	ldi	r23, 0x05	; 5
 7fa:	8a e4       	ldi	r24, 0x4A	; 74
 7fc:	96 e0       	ldi	r25, 0x06	; 6
 7fe:	0e 94 99 07 	call	0xf32	; 0xf32 <strstr>
 802:	89 2b       	or	r24, r25
 804:	09 f4       	brne	.+2      	; 0x808 <type_query_process+0x32>
 806:	51 c0       	rjmp	.+162    	; 0x8aa <type_query_process+0xd4>
 808:	6b e2       	ldi	r22, 0x2B	; 43
 80a:	70 e0       	ldi	r23, 0x00	; 0
 80c:	8a e4       	ldi	r24, 0x4A	; 74
 80e:	96 e0       	ldi	r25, 0x06	; 6
 810:	0e 94 87 07 	call	0xf0e	; 0xf0e <strchr>
 814:	89 2b       	or	r24, r25
 816:	09 f4       	brne	.+2      	; 0x81a <type_query_process+0x44>
 818:	4a c0       	rjmp	.+148    	; 0x8ae <type_query_process+0xd8>
 81a:	6a e3       	ldi	r22, 0x3A	; 58
 81c:	70 e0       	ldi	r23, 0x00	; 0
 81e:	8a e4       	ldi	r24, 0x4A	; 74
 820:	96 e0       	ldi	r25, 0x06	; 6
 822:	0e 94 87 07 	call	0xf0e	; 0xf0e <strchr>
 826:	89 2b       	or	r24, r25
 828:	09 f4       	brne	.+2      	; 0x82c <type_query_process+0x56>
 82a:	43 c0       	rjmp	.+134    	; 0x8b2 <type_query_process+0xdc>
	{
		query_data_flag.message_length = strlen(query_data_flag.message);				//如果接收完成，则计算字符串长度
 82c:	ea e4       	ldi	r30, 0x4A	; 74
 82e:	f6 e0       	ldi	r31, 0x06	; 6
 830:	01 90       	ld	r0, Z+
 832:	00 20       	and	r0, r0
 834:	e9 f7       	brne	.-6      	; 0x830 <type_query_process+0x5a>
 836:	31 97       	sbiw	r30, 0x01	; 1
 838:	ea 54       	subi	r30, 0x4A	; 74
 83a:	f6 40       	sbci	r31, 0x06	; 6
 83c:	2e 2f       	mov	r18, r30
 83e:	e0 93 49 07 	sts	0x0749, r30	; 0x800749 <query_data_flag+0xff>
		for (unsigned char i = 0 ; i < query_data_flag.message_length ; i++)	//循环处理字符串，将标志与信息记录在query_data_flag结构体里
 842:	ee 23       	and	r30, r30
 844:	11 f1       	breq	.+68     	; 0x88a <type_query_process+0xb4>
 846:	40 91 4a 07 	lds	r20, 0x074A	; 0x80074a <query_data_flag+0x100>
 84a:	50 91 4b 07 	lds	r21, 0x074B	; 0x80074b <query_data_flag+0x101>
 84e:	ea e4       	ldi	r30, 0x4A	; 74
 850:	f6 e0       	ldi	r31, 0x06	; 6
 852:	30 e0       	ldi	r19, 0x00	; 0
 854:	80 e0       	ldi	r24, 0x00	; 0
		{
			if (query_data_flag.message[i] == '+')								//判断如果是”+“则记录”+“位置
 856:	91 91       	ld	r25, Z+
 858:	9b 32       	cpi	r25, 0x2B	; 43
 85a:	59 f0       	breq	.+22     	; 0x872 <type_query_process+0x9c>
			{
				query_data_flag.add_offset = i;
			}else if (query_data_flag.message[i] == ':')						//判断如果是”：“则记录”：“位置
 85c:	9a 33       	cpi	r25, 0x3A	; 58
 85e:	59 f0       	breq	.+22     	; 0x876 <type_query_process+0xa0>
			{
				query_data_flag.colon_offset = i;
			}else if (query_data_flag.message[i] == ',')						//判断如果是”，“则记录”，“位置，并存储在数组内
 860:	9c 32       	cpi	r25, 0x2C	; 44
 862:	51 f4       	brne	.+20     	; 0x878 <type_query_process+0xa2>
			{
				query_data_flag.comma_offset[query_data_flag.comma_offset_number] = i;
 864:	a3 2f       	mov	r26, r19
 866:	b0 e0       	ldi	r27, 0x00	; 0
 868:	a3 5b       	subi	r26, 0xB3	; 179
 86a:	b8 4f       	sbci	r27, 0xF8	; 248
 86c:	8c 93       	st	X, r24
				query_data_flag.comma_offset_number++;
 86e:	3f 5f       	subi	r19, 0xFF	; 255
 870:	03 c0       	rjmp	.+6      	; 0x878 <type_query_process+0xa2>
		query_data_flag.message_length = strlen(query_data_flag.message);				//如果接收完成，则计算字符串长度
		for (unsigned char i = 0 ; i < query_data_flag.message_length ; i++)	//循环处理字符串，将标志与信息记录在query_data_flag结构体里
		{
			if (query_data_flag.message[i] == '+')								//判断如果是”+“则记录”+“位置
			{
				query_data_flag.add_offset = i;
 872:	48 2f       	mov	r20, r24
 874:	01 c0       	rjmp	.+2      	; 0x878 <type_query_process+0xa2>
			}else if (query_data_flag.message[i] == ':')						//判断如果是”：“则记录”：“位置
			{
				query_data_flag.colon_offset = i;
 876:	58 2f       	mov	r21, r24
	query_data_flag.comma_offset_number = 0;									//初始化逗号记录，记录有多少个逗号，就有+1个数据
	
	if (strstr(query_data_flag.message, bc95_response_ok)!= NULL && strstr(query_data_flag.message, "+") != NULL && strstr(query_data_flag.message, ":") != NULL)
	{
		query_data_flag.message_length = strlen(query_data_flag.message);				//如果接收完成，则计算字符串长度
		for (unsigned char i = 0 ; i < query_data_flag.message_length ; i++)	//循环处理字符串，将标志与信息记录在query_data_flag结构体里
 878:	8f 5f       	subi	r24, 0xFF	; 255
 87a:	28 13       	cpse	r18, r24
 87c:	ec cf       	rjmp	.-40     	; 0x856 <type_query_process+0x80>
 87e:	40 93 4a 07 	sts	0x074A, r20	; 0x80074a <query_data_flag+0x100>
 882:	50 93 4b 07 	sts	0x074B, r21	; 0x80074b <query_data_flag+0x101>
 886:	30 93 4c 07 	sts	0x074C, r19	; 0x80074c <query_data_flag+0x102>
			{
				query_data_flag.comma_offset[query_data_flag.comma_offset_number] = i;
				query_data_flag.comma_offset_number++;
			}
		}		
		return init_command[callback_function_number].callback_function();		//调用回调函数，并返回处理结果
 88a:	8c 2f       	mov	r24, r28
 88c:	90 e0       	ldi	r25, 0x00	; 0
 88e:	fc 01       	movw	r30, r24
 890:	ee 0f       	add	r30, r30
 892:	ff 1f       	adc	r31, r31
 894:	e8 0f       	add	r30, r24
 896:	f9 1f       	adc	r31, r25
 898:	ee 0f       	add	r30, r30
 89a:	ff 1f       	adc	r31, r31
 89c:	e0 50       	subi	r30, 0x00	; 0
 89e:	ff 4f       	sbci	r31, 0xFF	; 255
 8a0:	04 80       	ldd	r0, Z+4	; 0x04
 8a2:	f5 81       	ldd	r31, Z+5	; 0x05
 8a4:	e0 2d       	mov	r30, r0
 8a6:	09 95       	icall
 8a8:	05 c0       	rjmp	.+10     	; 0x8b4 <type_query_process+0xde>
	}	//判断是否出错，
	else if (strstr(query_data_flag.message, bc95_response_error) != NULL)				//如果检测到错误标志则返回0
	{
		return 0;
 8aa:	80 e0       	ldi	r24, 0x00	; 0
 8ac:	03 c0       	rjmp	.+6      	; 0x8b4 <type_query_process+0xde>
 8ae:	80 e0       	ldi	r24, 0x00	; 0
 8b0:	01 c0       	rjmp	.+2      	; 0x8b4 <type_query_process+0xde>
 8b2:	80 e0       	ldi	r24, 0x00	; 0
	}else{
		return 0;
	}
	return 0;
}
 8b4:	cf 91       	pop	r28
 8b6:	08 95       	ret

000008b8 <init_bc95>:
			在lcd上
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
void init_bc95(){
 8b8:	af 92       	push	r10
 8ba:	bf 92       	push	r11
 8bc:	cf 92       	push	r12
 8be:	df 92       	push	r13
 8c0:	ef 92       	push	r14
 8c2:	ff 92       	push	r15
 8c4:	0f 93       	push	r16
 8c6:	1f 93       	push	r17
 8c8:	cf 93       	push	r28
 8ca:	df 93       	push	r29
 8cc:	0f 2e       	mov	r0, r31
 8ce:	f0 e0       	ldi	r31, 0x00	; 0
 8d0:	ef 2e       	mov	r14, r31
 8d2:	f1 e0       	ldi	r31, 0x01	; 1
 8d4:	ff 2e       	mov	r15, r31
 8d6:	f0 2d       	mov	r31, r0
    for (unsigned char i = 0; i < 10; i++)
 8d8:	10 e0       	ldi	r17, 0x00	; 0
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
inline void set_bc95_query_data_flag_empty(){
	memset(&query_data_flag , 0, sizeof(struct bc95_query_data_flag));
 8da:	0f 2e       	mov	r0, r31
 8dc:	fa e4       	ldi	r31, 0x4A	; 74
 8de:	af 2e       	mov	r10, r31
 8e0:	f6 e0       	ldi	r31, 0x06	; 6
 8e2:	bf 2e       	mov	r11, r31
 8e4:	f0 2d       	mov	r31, r0
 8e6:	0f 2e       	mov	r0, r31
 8e8:	ff e0       	ldi	r31, 0x0F	; 15
 8ea:	cf 2e       	mov	r12, r31
 8ec:	dd 24       	eor	r13, r13
 8ee:	d3 94       	inc	r13
 8f0:	f0 2d       	mov	r31, r0
 8f2:	e7 01       	movw	r28, r14
* 返 回 值：无
*-----------------------------------------------------------------------------*/
void init_bc95(){
    for (unsigned char i = 0; i < 10; i++)
    {
		bc95_send_string(init_command[i].command);		
 8f4:	8a 81       	ldd	r24, Y+2	; 0x02
 8f6:	9b 81       	ldd	r25, Y+3	; 0x03
 8f8:	0e 94 0f 07 	call	0xe1e	; 0xe1e <bc95_send_string>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 8fc:	2f ef       	ldi	r18, 0xFF	; 255
 8fe:	8f ef       	ldi	r24, 0xFF	; 255
 900:	96 e8       	ldi	r25, 0x86	; 134
 902:	21 50       	subi	r18, 0x01	; 1
 904:	80 40       	sbci	r24, 0x00	; 0
 906:	90 40       	sbci	r25, 0x00	; 0
 908:	e1 f7       	brne	.-8      	; 0x902 <init_bc95+0x4a>
 90a:	00 c0       	rjmp	.+0      	; 0x90c <init_bc95+0x54>
 90c:	00 00       	nop
        unsigned char	resend_count = RESEND_NUMBER;       //初始化循环检查次数
		_delay_ms(BC95_COMMAND_DELAY);

        //根据发送的数据类型处理bc95返回的数据
        switch (init_command[i].type){
 90e:	88 81       	ld	r24, Y
 910:	82 30       	cpi	r24, 0x02	; 2
 912:	29 f1       	breq	.+74     	; 0x95e <init_bc95+0xa6>
 914:	83 30       	cpi	r24, 0x03	; 3
 916:	09 f4       	brne	.+2      	; 0x91a <init_bc95+0x62>
 918:	52 c0       	rjmp	.+164    	; 0x9be <init_bc95+0x106>
 91a:	81 30       	cpi	r24, 0x01	; 1
 91c:	09 f0       	breq	.+2      	; 0x920 <init_bc95+0x68>
 91e:	73 c0       	rjmp	.+230    	; 0xa06 <init_bc95+0x14e>
            case SET:
                //如果检测执行不成功则判断是否需要重新发送
                if (type_set_process() != 1){
 920:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <type_set_process>
 924:	81 30       	cpi	r24, 0x01	; 1
 926:	b1 f4       	brne	.+44     	; 0x954 <init_bc95+0x9c>
 928:	6e c0       	rjmp	.+220    	; 0xa06 <init_bc95+0x14e>
					//如果不成功且命令需要循环发送就循环发送最大循环次数并判断是否成功
                    while(((resend_count--) > 0) && (init_command[i].loop_config == LOOP)){
						bc95_send_string(init_command[i].command);
 92a:	8a 81       	ldd	r24, Y+2	; 0x02
 92c:	9b 81       	ldd	r25, Y+3	; 0x03
 92e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <bc95_send_string>
 932:	ff ef       	ldi	r31, 0xFF	; 255
 934:	2f ef       	ldi	r18, 0xFF	; 255
 936:	86 e8       	ldi	r24, 0x86	; 134
 938:	f1 50       	subi	r31, 0x01	; 1
 93a:	20 40       	sbci	r18, 0x00	; 0
 93c:	80 40       	sbci	r24, 0x00	; 0
 93e:	e1 f7       	brne	.-8      	; 0x938 <init_bc95+0x80>
 940:	00 c0       	rjmp	.+0      	; 0x942 <init_bc95+0x8a>
 942:	00 00       	nop

						_delay_ms(BC95_COMMAND_DELAY);
						//如果判断成功则退出循环发送下一条指令
                        if (type_set_process() == 1){
 944:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <type_set_process>
 948:	81 30       	cpi	r24, 0x01	; 1
 94a:	09 f4       	brne	.+2      	; 0x94e <init_bc95+0x96>
 94c:	5c c0       	rjmp	.+184    	; 0xa06 <init_bc95+0x14e>
 94e:	01 50       	subi	r16, 0x01	; 1
        switch (init_command[i].type){
            case SET:
                //如果检测执行不成功则判断是否需要重新发送
                if (type_set_process() != 1){
					//如果不成功且命令需要循环发送就循环发送最大循环次数并判断是否成功
                    while(((resend_count--) > 0) && (init_command[i].loop_config == LOOP)){
 950:	11 f4       	brne	.+4      	; 0x956 <init_bc95+0x9e>
 952:	59 c0       	rjmp	.+178    	; 0xa06 <init_bc95+0x14e>
 954:	0a e0       	ldi	r16, 0x0A	; 10
 956:	89 81       	ldd	r24, Y+1	; 0x01
 958:	81 30       	cpi	r24, 0x01	; 1
 95a:	39 f3       	breq	.-50     	; 0x92a <init_bc95+0x72>
 95c:	54 c0       	rjmp	.+168    	; 0xa06 <init_bc95+0x14e>

                break;

            case QUERY:
                //如果检测执行不成功则判断是否需要重新发送
                if (type_query_process(i) != 1){
 95e:	81 2f       	mov	r24, r17
 960:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <type_query_process>
 964:	81 30       	cpi	r24, 0x01	; 1
 966:	29 f1       	breq	.+74     	; 0x9b2 <init_bc95+0xfa>
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
inline void set_bc95_query_data_flag_empty(){
	memset(&query_data_flag , 0, sizeof(struct bc95_query_data_flag));
 968:	f5 01       	movw	r30, r10
 96a:	c6 01       	movw	r24, r12
 96c:	11 92       	st	Z+, r1
 96e:	01 97       	sbiw	r24, 0x01	; 1
 970:	e9 f7       	brne	.-6      	; 0x96c <init_bc95+0xb4>
            case QUERY:
                //如果检测执行不成功则判断是否需要重新发送
                if (type_query_process(i) != 1){
					set_bc95_query_data_flag_empty();			//清空数据标志结构体准备下一次接收
					//如果不成功且命令需要循环发送就循环发送最大循环次数并判断是否成功
                    while(((resend_count--) > 0) && (init_command[i].loop_config == LOOP)){
 972:	89 81       	ldd	r24, Y+1	; 0x01
 974:	81 30       	cpi	r24, 0x01	; 1
 976:	e9 f4       	brne	.+58     	; 0x9b2 <init_bc95+0xfa>
 978:	0a e0       	ldi	r16, 0x0A	; 10
						bc95_send_string(init_command[i].command);
 97a:	8a 81       	ldd	r24, Y+2	; 0x02
 97c:	9b 81       	ldd	r25, Y+3	; 0x03
 97e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <bc95_send_string>
 982:	9f ef       	ldi	r25, 0xFF	; 255
 984:	ef ef       	ldi	r30, 0xFF	; 255
 986:	f6 e8       	ldi	r31, 0x86	; 134
 988:	91 50       	subi	r25, 0x01	; 1
 98a:	e0 40       	sbci	r30, 0x00	; 0
 98c:	f0 40       	sbci	r31, 0x00	; 0
 98e:	e1 f7       	brne	.-8      	; 0x988 <init_bc95+0xd0>
 990:	00 c0       	rjmp	.+0      	; 0x992 <init_bc95+0xda>
 992:	00 00       	nop

						_delay_ms(BC95_COMMAND_DELAY);
                        if (type_query_process(i) == 1){
 994:	81 2f       	mov	r24, r17
 996:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <type_query_process>
 99a:	81 30       	cpi	r24, 0x01	; 1
 99c:	51 f0       	breq	.+20     	; 0x9b2 <init_bc95+0xfa>
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
inline void set_bc95_query_data_flag_empty(){
	memset(&query_data_flag , 0, sizeof(struct bc95_query_data_flag));
 99e:	f5 01       	movw	r30, r10
 9a0:	c6 01       	movw	r24, r12
 9a2:	11 92       	st	Z+, r1
 9a4:	01 97       	sbiw	r24, 0x01	; 1
 9a6:	e9 f7       	brne	.-6      	; 0x9a2 <init_bc95+0xea>
 9a8:	01 50       	subi	r16, 0x01	; 1
            case QUERY:
                //如果检测执行不成功则判断是否需要重新发送
                if (type_query_process(i) != 1){
					set_bc95_query_data_flag_empty();			//清空数据标志结构体准备下一次接收
					//如果不成功且命令需要循环发送就循环发送最大循环次数并判断是否成功
                    while(((resend_count--) > 0) && (init_command[i].loop_config == LOOP)){
 9aa:	19 f0       	breq	.+6      	; 0x9b2 <init_bc95+0xfa>
 9ac:	89 81       	ldd	r24, Y+1	; 0x01
 9ae:	81 30       	cpi	r24, 0x01	; 1
 9b0:	21 f3       	breq	.-56     	; 0x97a <init_bc95+0xc2>
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
inline void set_bc95_query_data_flag_empty(){
	memset(&query_data_flag , 0, sizeof(struct bc95_query_data_flag));
 9b2:	f5 01       	movw	r30, r10
 9b4:	c6 01       	movw	r24, r12
 9b6:	11 92       	st	Z+, r1
 9b8:	01 97       	sbiw	r24, 0x01	; 1
 9ba:	e9 f7       	brne	.-6      	; 0x9b6 <init_bc95+0xfe>
 9bc:	24 c0       	rjmp	.+72     	; 0xa06 <init_bc95+0x14e>
				set_bc95_query_data_flag_empty();				//清空数据标志结构体准备下一次接收
                break;

            case INFO:
                //如果检测执行不成功则判断是否需要重新发送
                if (type_info_process(i) != 1){
 9be:	81 2f       	mov	r24, r17
 9c0:	0e 94 8c 03 	call	0x718	; 0x718 <type_info_process>
 9c4:	81 30       	cpi	r24, 0x01	; 1
 9c6:	b1 f4       	brne	.+44     	; 0x9f4 <init_bc95+0x13c>
 9c8:	19 c0       	rjmp	.+50     	; 0x9fc <init_bc95+0x144>
					//如果不成功且命令需要循环发送就循环发送最大循环次数并判断是否成功
                    while(((resend_count--) > 0) && (init_command[i].loop_config == LOOP)){
						bc95_send_string(init_command[i].command);
 9ca:	8a 81       	ldd	r24, Y+2	; 0x02
 9cc:	9b 81       	ldd	r25, Y+3	; 0x03
 9ce:	0e 94 0f 07 	call	0xe1e	; 0xe1e <bc95_send_string>
 9d2:	9f ef       	ldi	r25, 0xFF	; 255
 9d4:	ef ef       	ldi	r30, 0xFF	; 255
 9d6:	f6 e8       	ldi	r31, 0x86	; 134
 9d8:	91 50       	subi	r25, 0x01	; 1
 9da:	e0 40       	sbci	r30, 0x00	; 0
 9dc:	f0 40       	sbci	r31, 0x00	; 0
 9de:	e1 f7       	brne	.-8      	; 0x9d8 <init_bc95+0x120>
 9e0:	00 c0       	rjmp	.+0      	; 0x9e2 <init_bc95+0x12a>
 9e2:	00 00       	nop
						_delay_ms(BC95_COMMAND_DELAY);			//延时一段时间再发送
                        if (type_info_process(i) == 1){
 9e4:	81 2f       	mov	r24, r17
 9e6:	0e 94 8c 03 	call	0x718	; 0x718 <type_info_process>
 9ea:	81 30       	cpi	r24, 0x01	; 1
 9ec:	39 f0       	breq	.+14     	; 0x9fc <init_bc95+0x144>
 9ee:	01 50       	subi	r16, 0x01	; 1

            case INFO:
                //如果检测执行不成功则判断是否需要重新发送
                if (type_info_process(i) != 1){
					//如果不成功且命令需要循环发送就循环发送最大循环次数并判断是否成功
                    while(((resend_count--) > 0) && (init_command[i].loop_config == LOOP)){
 9f0:	11 f4       	brne	.+4      	; 0x9f6 <init_bc95+0x13e>
 9f2:	04 c0       	rjmp	.+8      	; 0x9fc <init_bc95+0x144>
 9f4:	0a e0       	ldi	r16, 0x0A	; 10
 9f6:	89 81       	ldd	r24, Y+1	; 0x01
 9f8:	81 30       	cpi	r24, 0x01	; 1
 9fa:	39 f3       	breq	.-50     	; 0x9ca <init_bc95+0x112>
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
inline void set_bc95_query_data_flag_empty(){
	memset(&query_data_flag , 0, sizeof(struct bc95_query_data_flag));
 9fc:	f5 01       	movw	r30, r10
 9fe:	c6 01       	movw	r24, r12
 a00:	11 92       	st	Z+, r1
 a02:	01 97       	sbiw	r24, 0x01	; 1
 a04:	e9 f7       	brne	.-6      	; 0xa00 <init_bc95+0x148>
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
void init_bc95(){
    for (unsigned char i = 0; i < 10; i++)
 a06:	1f 5f       	subi	r17, 0xFF	; 255
 a08:	96 e0       	ldi	r25, 0x06	; 6
 a0a:	e9 0e       	add	r14, r25
 a0c:	f1 1c       	adc	r15, r1
 a0e:	1a 30       	cpi	r17, 0x0A	; 10
 a10:	09 f0       	breq	.+2      	; 0xa14 <init_bc95+0x15c>
 a12:	6f cf       	rjmp	.-290    	; 0x8f2 <init_bc95+0x3a>
                break;
            default:
                break;
        }
    }
}
 a14:	df 91       	pop	r29
 a16:	cf 91       	pop	r28
 a18:	1f 91       	pop	r17
 a1a:	0f 91       	pop	r16
 a1c:	ff 90       	pop	r15
 a1e:	ef 90       	pop	r14
 a20:	df 90       	pop	r13
 a22:	cf 90       	pop	r12
 a24:	bf 90       	pop	r11
 a26:	af 90       	pop	r10
 a28:	08 95       	ret

00000a2a <tm1726_start>:
void lcd_update_raw_ppm_display(unsigned int number){
	unsigned char cache[4] = {0};
	make_raw_ppm_number(number, cache);
	
	write_string_address_tm1726(14, 4, cache);
}
 a2a:	d8 9a       	sbi	0x1b, 0	; 27
 a2c:	d9 9a       	sbi	0x1b, 1	; 27
 a2e:	85 e2       	ldi	r24, 0x25	; 37
 a30:	8a 95       	dec	r24
 a32:	f1 f7       	brne	.-4      	; 0xa30 <tm1726_start+0x6>
 a34:	d8 98       	cbi	0x1b, 0	; 27
 a36:	85 e2       	ldi	r24, 0x25	; 37
 a38:	8a 95       	dec	r24
 a3a:	f1 f7       	brne	.-4      	; 0xa38 <tm1726_start+0xe>
 a3c:	d9 98       	cbi	0x1b, 1	; 27
 a3e:	85 e2       	ldi	r24, 0x25	; 37
 a40:	8a 95       	dec	r24
 a42:	f1 f7       	brne	.-4      	; 0xa40 <tm1726_start+0x16>
 a44:	08 95       	ret

00000a46 <tm1726_stop>:
 a46:	d8 98       	cbi	0x1b, 0	; 27
 a48:	d9 9a       	sbi	0x1b, 1	; 27
 a4a:	85 e2       	ldi	r24, 0x25	; 37
 a4c:	8a 95       	dec	r24
 a4e:	f1 f7       	brne	.-4      	; 0xa4c <tm1726_stop+0x6>
 a50:	d8 9a       	sbi	0x1b, 0	; 27
 a52:	85 e2       	ldi	r24, 0x25	; 37
 a54:	8a 95       	dec	r24
 a56:	f1 f7       	brne	.-4      	; 0xa54 <tm1726_stop+0xe>
 a58:	d9 98       	cbi	0x1b, 1	; 27
 a5a:	85 e2       	ldi	r24, 0x25	; 37
 a5c:	8a 95       	dec	r24
 a5e:	f1 f7       	brne	.-4      	; 0xa5c <tm1726_stop+0x16>
 a60:	08 95       	ret

00000a62 <write_byte_tm1726>:
 a62:	d8 98       	cbi	0x1b, 0	; 27
 a64:	d9 98       	cbi	0x1b, 1	; 27
 a66:	24 e0       	ldi	r18, 0x04	; 4
 a68:	2a 95       	dec	r18
 a6a:	f1 f7       	brne	.-4      	; 0xa68 <write_byte_tm1726+0x6>
 a6c:	98 e0       	ldi	r25, 0x08	; 8
 a6e:	d9 98       	cbi	0x1b, 1	; 27
 a70:	80 ff       	sbrs	r24, 0
 a72:	02 c0       	rjmp	.+4      	; 0xa78 <write_byte_tm1726+0x16>
 a74:	d8 9a       	sbi	0x1b, 0	; 27
 a76:	01 c0       	rjmp	.+2      	; 0xa7a <write_byte_tm1726+0x18>
 a78:	d8 98       	cbi	0x1b, 0	; 27
 a7a:	24 e0       	ldi	r18, 0x04	; 4
 a7c:	2a 95       	dec	r18
 a7e:	f1 f7       	brne	.-4      	; 0xa7c <write_byte_tm1726+0x1a>
 a80:	d9 9a       	sbi	0x1b, 1	; 27
 a82:	86 95       	lsr	r24
 a84:	91 50       	subi	r25, 0x01	; 1
 a86:	99 f7       	brne	.-26     	; 0xa6e <write_byte_tm1726+0xc>
 a88:	d9 98       	cbi	0x1b, 1	; 27
 a8a:	d8 98       	cbi	0x1b, 0	; 27
 a8c:	08 95       	ret

00000a8e <write_all_ram_tm1726>:
 a8e:	cf 93       	push	r28
 a90:	df 93       	push	r29
 a92:	d8 2f       	mov	r29, r24
 a94:	d8 9a       	sbi	0x1b, 0	; 27
 a96:	d9 9a       	sbi	0x1b, 1	; 27
 a98:	0e 94 15 05 	call	0xa2a	; 0xa2a <tm1726_start>
 a9c:	84 e0       	ldi	r24, 0x04	; 4
 a9e:	8a 95       	dec	r24
 aa0:	f1 f7       	brne	.-4      	; 0xa9e <write_all_ram_tm1726+0x10>
 aa2:	80 ec       	ldi	r24, 0xC0	; 192
 aa4:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte_tm1726>
 aa8:	c2 e1       	ldi	r28, 0x12	; 18
 aaa:	d8 9a       	sbi	0x1b, 0	; 27
 aac:	d9 9a       	sbi	0x1b, 1	; 27
 aae:	dd 23       	and	r29, r29
 ab0:	21 f0       	breq	.+8      	; 0xaba <write_all_ram_tm1726+0x2c>
 ab2:	8f ef       	ldi	r24, 0xFF	; 255
 ab4:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte_tm1726>
 ab8:	03 c0       	rjmp	.+6      	; 0xac0 <write_all_ram_tm1726+0x32>
 aba:	80 e0       	ldi	r24, 0x00	; 0
 abc:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte_tm1726>
 ac0:	c1 50       	subi	r28, 0x01	; 1
 ac2:	99 f7       	brne	.-26     	; 0xaaa <write_all_ram_tm1726+0x1c>
 ac4:	0e 94 23 05 	call	0xa46	; 0xa46 <tm1726_stop>
 ac8:	df 91       	pop	r29
 aca:	cf 91       	pop	r28
 acc:	08 95       	ret

00000ace <init_tm1726>:
 ace:	d8 9a       	sbi	0x1b, 0	; 27
 ad0:	d9 9a       	sbi	0x1b, 1	; 27
 ad2:	0e 94 15 05 	call	0xa2a	; 0xa2a <tm1726_start>
 ad6:	84 e0       	ldi	r24, 0x04	; 4
 ad8:	8a 95       	dec	r24
 ada:	f1 f7       	brne	.-4      	; 0xad8 <init_tm1726+0xa>
 adc:	87 e3       	ldi	r24, 0x37	; 55
 ade:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte_tm1726>
 ae2:	0e 94 23 05 	call	0xa46	; 0xa46 <tm1726_stop>
 ae6:	08 95       	ret

00000ae8 <write_byte_address_tm1726>:
 ae8:	cf 93       	push	r28
 aea:	df 93       	push	r29
 aec:	d8 2f       	mov	r29, r24
 aee:	c6 2f       	mov	r28, r22
 af0:	d8 9a       	sbi	0x1b, 0	; 27
 af2:	d9 9a       	sbi	0x1b, 1	; 27
 af4:	0e 94 15 05 	call	0xa2a	; 0xa2a <tm1726_start>
 af8:	8f ef       	ldi	r24, 0xFF	; 255
 afa:	9b e6       	ldi	r25, 0x6B	; 107
 afc:	01 97       	sbiw	r24, 0x01	; 1
 afe:	f1 f7       	brne	.-4      	; 0xafc <write_byte_address_tm1726+0x14>
 b00:	00 c0       	rjmp	.+0      	; 0xb02 <write_byte_address_tm1726+0x1a>
 b02:	00 00       	nop
 b04:	80 ec       	ldi	r24, 0xC0	; 192
 b06:	8d 0f       	add	r24, r29
 b08:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte_tm1726>
 b0c:	d8 9a       	sbi	0x1b, 0	; 27
 b0e:	d9 9a       	sbi	0x1b, 1	; 27
 b10:	8f ef       	ldi	r24, 0xFF	; 255
 b12:	9b e6       	ldi	r25, 0x6B	; 107
 b14:	01 97       	sbiw	r24, 0x01	; 1
 b16:	f1 f7       	brne	.-4      	; 0xb14 <write_byte_address_tm1726+0x2c>
 b18:	00 c0       	rjmp	.+0      	; 0xb1a <write_byte_address_tm1726+0x32>
 b1a:	00 00       	nop
 b1c:	8c 2f       	mov	r24, r28
 b1e:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte_tm1726>
 b22:	0e 94 23 05 	call	0xa46	; 0xa46 <tm1726_stop>
 b26:	df 91       	pop	r29
 b28:	cf 91       	pop	r28
 b2a:	08 95       	ret

00000b2c <write_string_address_tm1726>:
 b2c:	ef 92       	push	r14
 b2e:	ff 92       	push	r15
 b30:	1f 93       	push	r17
 b32:	cf 93       	push	r28
 b34:	df 93       	push	r29
 b36:	9f ef       	ldi	r25, 0xFF	; 255
 b38:	96 0f       	add	r25, r22
 b3a:	66 23       	and	r22, r22
 b3c:	89 f0       	breq	.+34     	; 0xb60 <write_string_address_tm1726+0x34>
 b3e:	ea 01       	movw	r28, r20
 b40:	e9 2e       	mov	r14, r25
 b42:	f1 2c       	mov	r15, r1
 b44:	9f ef       	ldi	r25, 0xFF	; 255
 b46:	e9 1a       	sub	r14, r25
 b48:	f9 0a       	sbc	r15, r25
 b4a:	e4 0e       	add	r14, r20
 b4c:	f5 1e       	adc	r15, r21
 b4e:	69 91       	ld	r22, Y+
 b50:	11 e0       	ldi	r17, 0x01	; 1
 b52:	18 0f       	add	r17, r24
 b54:	0e 94 74 05 	call	0xae8	; 0xae8 <write_byte_address_tm1726>
 b58:	81 2f       	mov	r24, r17
 b5a:	ce 15       	cp	r28, r14
 b5c:	df 05       	cpc	r29, r15
 b5e:	b9 f7       	brne	.-18     	; 0xb4e <write_string_address_tm1726+0x22>
 b60:	df 91       	pop	r29
 b62:	cf 91       	pop	r28
 b64:	1f 91       	pop	r17
 b66:	ff 90       	pop	r15
 b68:	ef 90       	pop	r14
 b6a:	08 95       	ret

00000b6c <init_lcd>:
 b6c:	0e 94 67 05 	call	0xace	; 0xace <init_tm1726>
 b70:	2f ef       	ldi	r18, 0xFF	; 255
 b72:	8f eb       	ldi	r24, 0xBF	; 191
 b74:	96 e0       	ldi	r25, 0x06	; 6
 b76:	21 50       	subi	r18, 0x01	; 1
 b78:	80 40       	sbci	r24, 0x00	; 0
 b7a:	90 40       	sbci	r25, 0x00	; 0
 b7c:	e1 f7       	brne	.-8      	; 0xb76 <init_lcd+0xa>
 b7e:	00 c0       	rjmp	.+0      	; 0xb80 <init_lcd+0x14>
 b80:	00 00       	nop
 b82:	81 e0       	ldi	r24, 0x01	; 1
 b84:	0e 94 47 05 	call	0xa8e	; 0xa8e <write_all_ram_tm1726>
 b88:	2f ef       	ldi	r18, 0xFF	; 255
 b8a:	8f eb       	ldi	r24, 0xBF	; 191
 b8c:	91 e2       	ldi	r25, 0x21	; 33
 b8e:	21 50       	subi	r18, 0x01	; 1
 b90:	80 40       	sbci	r24, 0x00	; 0
 b92:	90 40       	sbci	r25, 0x00	; 0
 b94:	e1 f7       	brne	.-8      	; 0xb8e <init_lcd+0x22>
 b96:	00 c0       	rjmp	.+0      	; 0xb98 <init_lcd+0x2c>
 b98:	00 00       	nop
 b9a:	80 e0       	ldi	r24, 0x00	; 0
 b9c:	0e 94 47 05 	call	0xa8e	; 0xa8e <write_all_ram_tm1726>
 ba0:	08 95       	ret

00000ba2 <make_pure_ppm_number>:
	}else{
		number_array[0] &= ~NO_WATER_ICON;
	}
}

void make_pure_ppm_number(unsigned int number, unsigned char *number_array){
 ba2:	0f 93       	push	r16
 ba4:	1f 93       	push	r17
 ba6:	cf 93       	push	r28
 ba8:	df 93       	push	r29
 baa:	8c 01       	movw	r16, r24
 bac:	eb 01       	movw	r28, r22
	
	number_array[0] =SMG[ (number%10) ] | PURE_WATER_ICON;
 bae:	9c 01       	movw	r18, r24
 bb0:	ad ec       	ldi	r26, 0xCD	; 205
 bb2:	bc ec       	ldi	r27, 0xCC	; 204
 bb4:	0e 94 78 07 	call	0xef0	; 0xef0 <__umulhisi3>
 bb8:	ac 01       	movw	r20, r24
 bba:	56 95       	lsr	r21
 bbc:	47 95       	ror	r20
 bbe:	56 95       	lsr	r21
 bc0:	47 95       	ror	r20
 bc2:	56 95       	lsr	r21
 bc4:	47 95       	ror	r20
 bc6:	9a 01       	movw	r18, r20
 bc8:	22 0f       	add	r18, r18
 bca:	33 1f       	adc	r19, r19
 bcc:	ca 01       	movw	r24, r20
 bce:	88 0f       	add	r24, r24
 bd0:	99 1f       	adc	r25, r25
 bd2:	88 0f       	add	r24, r24
 bd4:	99 1f       	adc	r25, r25
 bd6:	88 0f       	add	r24, r24
 bd8:	99 1f       	adc	r25, r25
 bda:	82 0f       	add	r24, r18
 bdc:	93 1f       	adc	r25, r19
 bde:	f8 01       	movw	r30, r16
 be0:	e8 1b       	sub	r30, r24
 be2:	f9 0b       	sbc	r31, r25
 be4:	ec 54       	subi	r30, 0x4C	; 76
 be6:	fe 4f       	sbci	r31, 0xFE	; 254
 be8:	80 81       	ld	r24, Z
 bea:	80 61       	ori	r24, 0x10	; 16
 bec:	88 83       	st	Y, r24
	number_array[1] =SMG[ ((number/10)%10) ];
 bee:	9a 01       	movw	r18, r20
 bf0:	0e 94 78 07 	call	0xef0	; 0xef0 <__umulhisi3>
 bf4:	96 95       	lsr	r25
 bf6:	87 95       	ror	r24
 bf8:	96 95       	lsr	r25
 bfa:	87 95       	ror	r24
 bfc:	96 95       	lsr	r25
 bfe:	87 95       	ror	r24
 c00:	9c 01       	movw	r18, r24
 c02:	22 0f       	add	r18, r18
 c04:	33 1f       	adc	r19, r19
 c06:	88 0f       	add	r24, r24
 c08:	99 1f       	adc	r25, r25
 c0a:	88 0f       	add	r24, r24
 c0c:	99 1f       	adc	r25, r25
 c0e:	88 0f       	add	r24, r24
 c10:	99 1f       	adc	r25, r25
 c12:	82 0f       	add	r24, r18
 c14:	93 1f       	adc	r25, r19
 c16:	48 1b       	sub	r20, r24
 c18:	59 0b       	sbc	r21, r25
 c1a:	fa 01       	movw	r30, r20
 c1c:	ec 54       	subi	r30, 0x4C	; 76
 c1e:	fe 4f       	sbci	r31, 0xFE	; 254
 c20:	80 81       	ld	r24, Z
 c22:	89 83       	std	Y+1, r24	; 0x01
	number_array[2] =SMG[ ((number/100)%10) ];
 c24:	98 01       	movw	r18, r16
 c26:	36 95       	lsr	r19
 c28:	27 95       	ror	r18
 c2a:	36 95       	lsr	r19
 c2c:	27 95       	ror	r18
 c2e:	ab e7       	ldi	r26, 0x7B	; 123
 c30:	b4 e1       	ldi	r27, 0x14	; 20
 c32:	0e 94 78 07 	call	0xef0	; 0xef0 <__umulhisi3>
 c36:	ac 01       	movw	r20, r24
 c38:	56 95       	lsr	r21
 c3a:	47 95       	ror	r20
 c3c:	9a 01       	movw	r18, r20
 c3e:	ad ec       	ldi	r26, 0xCD	; 205
 c40:	bc ec       	ldi	r27, 0xCC	; 204
 c42:	0e 94 78 07 	call	0xef0	; 0xef0 <__umulhisi3>
 c46:	96 95       	lsr	r25
 c48:	87 95       	ror	r24
 c4a:	96 95       	lsr	r25
 c4c:	87 95       	ror	r24
 c4e:	96 95       	lsr	r25
 c50:	87 95       	ror	r24
 c52:	9c 01       	movw	r18, r24
 c54:	22 0f       	add	r18, r18
 c56:	33 1f       	adc	r19, r19
 c58:	88 0f       	add	r24, r24
 c5a:	99 1f       	adc	r25, r25
 c5c:	88 0f       	add	r24, r24
 c5e:	99 1f       	adc	r25, r25
 c60:	88 0f       	add	r24, r24
 c62:	99 1f       	adc	r25, r25
 c64:	82 0f       	add	r24, r18
 c66:	93 1f       	adc	r25, r19
 c68:	48 1b       	sub	r20, r24
 c6a:	59 0b       	sbc	r21, r25
 c6c:	fa 01       	movw	r30, r20
 c6e:	ec 54       	subi	r30, 0x4C	; 76
 c70:	fe 4f       	sbci	r31, 0xFE	; 254
 c72:	80 81       	ld	r24, Z
 c74:	8a 83       	std	Y+2, r24	; 0x02
	number_array[3] =SMG[ ((number/1000)%10) ];
 c76:	98 01       	movw	r18, r16
 c78:	36 95       	lsr	r19
 c7a:	27 95       	ror	r18
 c7c:	36 95       	lsr	r19
 c7e:	27 95       	ror	r18
 c80:	36 95       	lsr	r19
 c82:	27 95       	ror	r18
 c84:	a5 ec       	ldi	r26, 0xC5	; 197
 c86:	b0 e2       	ldi	r27, 0x20	; 32
 c88:	0e 94 78 07 	call	0xef0	; 0xef0 <__umulhisi3>
 c8c:	ac 01       	movw	r20, r24
 c8e:	52 95       	swap	r21
 c90:	42 95       	swap	r20
 c92:	4f 70       	andi	r20, 0x0F	; 15
 c94:	45 27       	eor	r20, r21
 c96:	5f 70       	andi	r21, 0x0F	; 15
 c98:	45 27       	eor	r20, r21
 c9a:	9a 01       	movw	r18, r20
 c9c:	ad ec       	ldi	r26, 0xCD	; 205
 c9e:	bc ec       	ldi	r27, 0xCC	; 204
 ca0:	0e 94 78 07 	call	0xef0	; 0xef0 <__umulhisi3>
 ca4:	96 95       	lsr	r25
 ca6:	87 95       	ror	r24
 ca8:	96 95       	lsr	r25
 caa:	87 95       	ror	r24
 cac:	96 95       	lsr	r25
 cae:	87 95       	ror	r24
 cb0:	9c 01       	movw	r18, r24
 cb2:	22 0f       	add	r18, r18
 cb4:	33 1f       	adc	r19, r19
 cb6:	88 0f       	add	r24, r24
 cb8:	99 1f       	adc	r25, r25
 cba:	88 0f       	add	r24, r24
 cbc:	99 1f       	adc	r25, r25
 cbe:	88 0f       	add	r24, r24
 cc0:	99 1f       	adc	r25, r25
 cc2:	82 0f       	add	r24, r18
 cc4:	93 1f       	adc	r25, r19
 cc6:	48 1b       	sub	r20, r24
 cc8:	59 0b       	sbc	r21, r25
 cca:	fa 01       	movw	r30, r20
 ccc:	ec 54       	subi	r30, 0x4C	; 76
 cce:	fe 4f       	sbci	r31, 0xFE	; 254
 cd0:	80 81       	ld	r24, Z
 cd2:	8b 83       	std	Y+3, r24	; 0x03
	
	if (device_status_lcd.leakage)
 cd4:	90 91 5e 09 	lds	r25, 0x095E	; 0x80095e <device_status_lcd+0x2>
 cd8:	99 23       	and	r25, r25
 cda:	19 f0       	breq	.+6      	; 0xce2 <make_pure_ppm_number+0x140>
	{
		number_array[3] |= LEAKAGE_ICON;
 cdc:	80 61       	ori	r24, 0x10	; 16
 cde:	8b 83       	std	Y+3, r24	; 0x03
 ce0:	02 c0       	rjmp	.+4      	; 0xce6 <make_pure_ppm_number+0x144>
	}else{
		number_array[3] &= ~LEAKAGE_ICON;
 ce2:	8f 7e       	andi	r24, 0xEF	; 239
 ce4:	8b 83       	std	Y+3, r24	; 0x03
	}

}
 ce6:	df 91       	pop	r29
 ce8:	cf 91       	pop	r28
 cea:	1f 91       	pop	r17
 cec:	0f 91       	pop	r16
 cee:	08 95       	ret

00000cf0 <lcd_update_pure_ppm_display>:
* 入口参数：	unsigned long int	number			要显示的数字

* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
void lcd_update_pure_ppm_display(unsigned int number){
 cf0:	cf 93       	push	r28
 cf2:	df 93       	push	r29
 cf4:	00 d0       	rcall	.+0      	; 0xcf6 <lcd_update_pure_ppm_display+0x6>
 cf6:	00 d0       	rcall	.+0      	; 0xcf8 <lcd_update_pure_ppm_display+0x8>
 cf8:	cd b7       	in	r28, 0x3d	; 61
 cfa:	de b7       	in	r29, 0x3e	; 62
	unsigned char cache[4] = {0};
 cfc:	19 82       	std	Y+1, r1	; 0x01
 cfe:	1a 82       	std	Y+2, r1	; 0x02
 d00:	1b 82       	std	Y+3, r1	; 0x03
 d02:	1c 82       	std	Y+4, r1	; 0x04
	make_pure_ppm_number(number, cache);
 d04:	be 01       	movw	r22, r28
 d06:	6f 5f       	subi	r22, 0xFF	; 255
 d08:	7f 4f       	sbci	r23, 0xFF	; 255
 d0a:	0e 94 d1 05 	call	0xba2	; 0xba2 <make_pure_ppm_number>
	write_string_address_tm1726(10, 4, cache);
 d0e:	ae 01       	movw	r20, r28
 d10:	4f 5f       	subi	r20, 0xFF	; 255
 d12:	5f 4f       	sbci	r21, 0xFF	; 255
 d14:	64 e0       	ldi	r22, 0x04	; 4
 d16:	8a e0       	ldi	r24, 0x0A	; 10
 d18:	0e 94 96 05 	call	0xb2c	; 0xb2c <write_string_address_tm1726>
}
 d1c:	0f 90       	pop	r0
 d1e:	0f 90       	pop	r0
 d20:	0f 90       	pop	r0
 d22:	0f 90       	pop	r0
 d24:	df 91       	pop	r29
 d26:	cf 91       	pop	r28
 d28:	08 95       	ret

00000d2a <init_port>:
	---------------------------------------
		TM1726	端口初始化
			SDA				PA0		OUT
			SCL				PA1		OUT
	-------------------------------------*/
	DDRA |= ((1 << PA0) | (1 << PA1) | (1 << PA2) | (1 << PA3));
 d2a:	8a b3       	in	r24, 0x1a	; 26
 d2c:	8f 60       	ori	r24, 0x0F	; 15
 d2e:	8a bb       	out	0x1a, r24	; 26
	
	/*------------------------------------
		ADC		端口初始化
	------------------------------------*/
	PORTF &= ~((0x01<< PF7) | (0x01<<PF6 )|(0x01<<PF5));
 d30:	e2 e6       	ldi	r30, 0x62	; 98
 d32:	f0 e0       	ldi	r31, 0x00	; 0
 d34:	80 81       	ld	r24, Z
 d36:	8f 71       	andi	r24, 0x1F	; 31
 d38:	80 83       	st	Z, r24
	DDRF  &= ~((0x01<< PF7) | (0x01<<PF6) |(0x01<<PF5));
 d3a:	e1 e6       	ldi	r30, 0x61	; 97
 d3c:	f0 e0       	ldi	r31, 0x00	; 0
 d3e:	80 81       	ld	r24, Z
 d40:	8f 71       	andi	r24, 0x1F	; 31
 d42:	80 83       	st	Z, r24
	
	/*------------------------------------
		uart	端口初始化
	------------------------------------*/
	DDRE	|=	 (1 << PE1);		//TXD设置为输出
 d44:	11 9a       	sbi	0x02, 1	; 2
	DDRE	&=	~(1 << PE0);		//RXD设置为输入
 d46:	10 98       	cbi	0x02, 0	; 2
	PORTE	&=	 0xFF;				//uart0
 d48:	83 b1       	in	r24, 0x03	; 3
 d4a:	83 b9       	out	0x03, r24	; 3
	
	DDRD	|=	 (1 << PD3);		//TXD设置为输出
 d4c:	8b 9a       	sbi	0x11, 3	; 17
	DDRD	&=	~(1 << PD2);		//RXD设置为输入
 d4e:	8a 98       	cbi	0x11, 2	; 17
	PORTD	&=	 0xFF;				//uart1
 d50:	82 b3       	in	r24, 0x12	; 18
 d52:	82 bb       	out	0x12, r24	; 18
	
	/*------------------------------------
		led		端口初始化
	------------------------------------*/
	DDRC	|=	(1 << PC0);			//PC0设置为输出
 d54:	a0 9a       	sbi	0x14, 0	; 20
	PORTC	|=	(1 << PC0);			//熄灭led
 d56:	a8 9a       	sbi	0x15, 0	; 21
	
	/*------------------------------------
		beep	端口初始化
	------------------------------------*/
	DDRB	|=	 (1 << PB0);		//PB0设置为输出
 d58:	b8 9a       	sbi	0x17, 0	; 23
	PORTB	&=	~(1 << PB0);		//蜂鸣器不响
 d5a:	c0 98       	cbi	0x18, 0	; 24

	/*------------------------------------
		TM1726背光灯	端口初始化
	------------------------------------*/
	DDRE	|=	(1 << PE2);			//PE2设置为输出
 d5c:	12 9a       	sbi	0x02, 2	; 2
	PORTE	|=	(1 << PE2);			//打开背光	
 d5e:	1a 9a       	sbi	0x03, 2	; 3
	/*------------------------------------
		TM1726串行	端口初始化
			PA0		SDA		设置为输出
			PA1		SCL		设置为输出
	------------------------------------*/	
	DDRA	|=	((1 << PA0) | (1 << PA1));
 d60:	8a b3       	in	r24, 0x1a	; 26
 d62:	83 60       	ori	r24, 0x03	; 3
 d64:	8a bb       	out	0x1a, r24	; 26
	PORTA	|=	((1 << PA0) | (1 << PA1));
 d66:	8b b3       	in	r24, 0x1b	; 27
 d68:	83 60       	ori	r24, 0x03	; 3
 d6a:	8b bb       	out	0x1b, r24	; 27
		电磁阀	端口初始化
			PE7		进水电磁阀		设置为输出
			PE6		出水电磁阀		设置为输出
			初始化为关闭
	------------------------------------*/	
	DDRE	|=	((1 << PE7) | (1 << PE6));
 d6c:	82 b1       	in	r24, 0x02	; 2
 d6e:	80 6c       	ori	r24, 0xC0	; 192
 d70:	82 b9       	out	0x02, r24	; 2
	PORTE	&= ~((1 << PE7) | (1 << PE6));
 d72:	83 b1       	in	r24, 0x03	; 3
 d74:	8f 73       	andi	r24, 0x3F	; 63
 d76:	83 b9       	out	0x03, r24	; 3
	
	/*------------------------------------
		水泵	端口初始化
	------------------------------------*/	
	DDRB	|=	(1 << PB2);			//PB2设置为输出
 d78:	ba 9a       	sbi	0x17, 2	; 23
	PORTB	&= ~(1 << PB2);			//初始化为关闭
 d7a:	c2 98       	cbi	0x18, 2	; 24
	
	/*------------------------------------
		压力开关	端口初始化	
		初始化为输入
	------------------------------------*/	
	DDRB	&= ~((1 << PB6) | (1 << PB7));
 d7c:	87 b3       	in	r24, 0x17	; 23
 d7e:	8f 73       	andi	r24, 0x3F	; 63
 d80:	87 bb       	out	0x17, r24	; 23
	PORTB	|=	((1 << PB6) | (1 << PB7));
 d82:	88 b3       	in	r24, 0x18	; 24
 d84:	80 6c       	ori	r24, 0xC0	; 192
 d86:	88 bb       	out	0x18, r24	; 24
 d88:	08 95       	ret

00000d8a <init_uart0>:
* 入口参数：无
* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
inline void uart0_rx_array_set_empty(){
	memset(uart0_rx_array , 0 , sizeof(uart0_rx_array));
 d8a:	86 e0       	ldi	r24, 0x06	; 6
 d8c:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
 d90:	87 e4       	ldi	r24, 0x47	; 71
 d92:	89 b9       	out	0x09, r24	; 9
 d94:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
 d98:	8a b1       	in	r24, 0x0a	; 10
 d9a:	88 69       	ori	r24, 0x98	; 152
 d9c:	8a b9       	out	0x0a, r24	; 10
 d9e:	08 95       	ret

00000da0 <init_uart1>:
 da0:	ed e9       	ldi	r30, 0x9D	; 157
 da2:	f0 e0       	ldi	r31, 0x00	; 0
 da4:	80 81       	ld	r24, Z
 da6:	86 60       	ori	r24, 0x06	; 6
 da8:	80 83       	st	Z, r24
 daa:	8f e8       	ldi	r24, 0x8F	; 143
 dac:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
 db0:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
 db4:	eb e9       	ldi	r30, 0x9B	; 155
 db6:	f0 e0       	ldi	r31, 0x00	; 0
 db8:	80 81       	ld	r24, Z
 dba:	82 60       	ori	r24, 0x02	; 2
 dbc:	80 83       	st	Z, r24
 dbe:	ea e9       	ldi	r30, 0x9A	; 154
 dc0:	f0 e0       	ldi	r31, 0x00	; 0
 dc2:	80 81       	ld	r24, Z
 dc4:	88 69       	ori	r24, 0x98	; 152
 dc6:	80 83       	st	Z, r24
 dc8:	08 95       	ret

00000dca <uart0_send_byte>:
 dca:	5d 9b       	sbis	0x0b, 5	; 11
 dcc:	fe cf       	rjmp	.-4      	; 0xdca <uart0_send_byte>
 dce:	8c b9       	out	0x0c, r24	; 12
 dd0:	08 95       	ret

00000dd2 <uart0_send_string>:
 dd2:	cf 93       	push	r28
 dd4:	df 93       	push	r29
 dd6:	ec 01       	movw	r28, r24
 dd8:	88 81       	ld	r24, Y
 dda:	88 23       	and	r24, r24
 ddc:	31 f0       	breq	.+12     	; 0xdea <uart0_send_string+0x18>
 dde:	21 96       	adiw	r28, 0x01	; 1
 de0:	0e 94 e5 06 	call	0xdca	; 0xdca <uart0_send_byte>
 de4:	89 91       	ld	r24, Y+
 de6:	81 11       	cpse	r24, r1
 de8:	fb cf       	rjmp	.-10     	; 0xde0 <uart0_send_string+0xe>
 dea:	df 91       	pop	r29
 dec:	cf 91       	pop	r28
 dee:	08 95       	ret

00000df0 <uart1_send_byte>:
 df0:	eb e9       	ldi	r30, 0x9B	; 155
 df2:	f0 e0       	ldi	r31, 0x00	; 0
 df4:	90 81       	ld	r25, Z
 df6:	95 ff       	sbrs	r25, 5
 df8:	fd cf       	rjmp	.-6      	; 0xdf4 <uart1_send_byte+0x4>
 dfa:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
 dfe:	08 95       	ret

00000e00 <uart1_send_string>:
 e00:	cf 93       	push	r28
 e02:	df 93       	push	r29
 e04:	ec 01       	movw	r28, r24
 e06:	88 81       	ld	r24, Y
 e08:	88 23       	and	r24, r24
 e0a:	31 f0       	breq	.+12     	; 0xe18 <uart1_send_string+0x18>
 e0c:	21 96       	adiw	r28, 0x01	; 1
 e0e:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <uart1_send_byte>
 e12:	89 91       	ld	r24, Y+
 e14:	81 11       	cpse	r24, r1
 e16:	fb cf       	rjmp	.-10     	; 0xe0e <uart1_send_string+0xe>
 e18:	df 91       	pop	r29
 e1a:	cf 91       	pop	r28
 e1c:	08 95       	ret

00000e1e <bc95_send_string>:
 e1e:	cf 93       	push	r28
 e20:	df 93       	push	r29
 e22:	ec 01       	movw	r28, r24
 e24:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <uart0_send_string>
 e28:	ce 01       	movw	r24, r28
 e2a:	0e 94 00 07 	call	0xe00	; 0xe00 <uart1_send_string>
 e2e:	df 91       	pop	r29
 e30:	cf 91       	pop	r28
 e32:	08 95       	ret

00000e34 <uart1_rx_array_set_empty>:
 e34:	89 ec       	ldi	r24, 0xC9	; 201
 e36:	ef e5       	ldi	r30, 0x5F	; 95
 e38:	f9 e0       	ldi	r31, 0x09	; 9
 e3a:	df 01       	movw	r26, r30
 e3c:	1d 92       	st	X+, r1
 e3e:	8a 95       	dec	r24
 e40:	e9 f7       	brne	.-6      	; 0xe3c <uart1_rx_array_set_empty+0x8>
 e42:	08 95       	ret

00000e44 <__vector_18>:
* 中断向量：USART0_RX_vect	接收完成

* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
SIGNAL(USART0_RX_vect){
 e44:	1f 92       	push	r1
 e46:	0f 92       	push	r0
 e48:	0f b6       	in	r0, 0x3f	; 63
 e4a:	0f 92       	push	r0
 e4c:	11 24       	eor	r1, r1
 e4e:	8f 93       	push	r24
 e50:	9f 93       	push	r25
 e52:	ef 93       	push	r30
 e54:	ff 93       	push	r31
	if (uart0_rx_count >= UART0_RX_ARRAY_LEN)
 e56:	80 91 69 05 	lds	r24, 0x0569	; 0x800569 <uart0_rx_count>
 e5a:	88 3c       	cpi	r24, 0xC8	; 200
 e5c:	10 f0       	brcs	.+4      	; 0xe62 <__vector_18+0x1e>
	{
		uart0_rx_count = 0;
 e5e:	10 92 69 05 	sts	0x0569, r1	; 0x800569 <uart0_rx_count>
	}
	while(!(UCSR0A & (1 << RXC0)));		//判断缓冲区是否有数据
 e62:	5f 9b       	sbis	0x0b, 7	; 11
 e64:	fe cf       	rjmp	.-4      	; 0xe62 <__vector_18+0x1e>
	uart0_rx_array[uart0_rx_count] = UDR0;
 e66:	80 91 69 05 	lds	r24, 0x0569	; 0x800569 <uart0_rx_count>
 e6a:	9c b1       	in	r25, 0x0c	; 12
 e6c:	e8 2f       	mov	r30, r24
 e6e:	f0 e0       	ldi	r31, 0x00	; 0
 e70:	e6 59       	subi	r30, 0x96	; 150
 e72:	fa 4f       	sbci	r31, 0xFA	; 250
 e74:	90 83       	st	Z, r25
	uart0_rx_count++;
 e76:	8f 5f       	subi	r24, 0xFF	; 255
 e78:	80 93 69 05 	sts	0x0569, r24	; 0x800569 <uart0_rx_count>
	
}
 e7c:	ff 91       	pop	r31
 e7e:	ef 91       	pop	r30
 e80:	9f 91       	pop	r25
 e82:	8f 91       	pop	r24
 e84:	0f 90       	pop	r0
 e86:	0f be       	out	0x3f, r0	; 63
 e88:	0f 90       	pop	r0
 e8a:	1f 90       	pop	r1
 e8c:	18 95       	reti

00000e8e <__vector_30>:
* 中断向量：USART1_RX_vect	接收完成

* 出口参数：无
* 返 回 值：无
*-----------------------------------------------------------------------------*/
SIGNAL(USART1_RX_vect){
 e8e:	1f 92       	push	r1
 e90:	0f 92       	push	r0
 e92:	0f b6       	in	r0, 0x3f	; 63
 e94:	0f 92       	push	r0
 e96:	11 24       	eor	r1, r1
 e98:	8f 93       	push	r24
 e9a:	9f 93       	push	r25
 e9c:	af 93       	push	r26
 e9e:	bf 93       	push	r27
 ea0:	ef 93       	push	r30
 ea2:	ff 93       	push	r31
	//如果接收数据的数组长度大于定义的最大长度则将计数清0
	if (uart1_rx_data.message_length >= UART1_RX_ARRAY_LEN)
 ea4:	80 91 27 0a 	lds	r24, 0x0A27	; 0x800a27 <uart1_rx_data+0xc8>
 ea8:	88 3c       	cpi	r24, 0xC8	; 200
 eaa:	10 f0       	brcs	.+4      	; 0xeb0 <__vector_30+0x22>
	{
		uart1_rx_data.message_length = 0;
 eac:	10 92 27 0a 	sts	0x0A27, r1	; 0x800a27 <uart1_rx_data+0xc8>
	}
	
	while( !(UCSR1A & (1<<RXC1)) );								//判断缓冲区是否有数据
 eb0:	eb e9       	ldi	r30, 0x9B	; 155
 eb2:	f0 e0       	ldi	r31, 0x00	; 0
 eb4:	80 81       	ld	r24, Z
 eb6:	88 23       	and	r24, r24
 eb8:	ec f7       	brge	.-6      	; 0xeb4 <__vector_30+0x26>
	uart1_rx_data.message[uart1_rx_data.message_length] = UDR1;		//保存接收到的数据
 eba:	a7 e2       	ldi	r26, 0x27	; 39
 ebc:	ba e0       	ldi	r27, 0x0A	; 10
 ebe:	8c 91       	ld	r24, X
 ec0:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
 ec4:	e8 2f       	mov	r30, r24
 ec6:	f0 e0       	ldi	r31, 0x00	; 0
 ec8:	e1 5a       	subi	r30, 0xA1	; 161
 eca:	f6 4f       	sbci	r31, 0xF6	; 246
 ecc:	90 83       	st	Z, r25
	uart1_rx_data.message_length++;									//计数
 ece:	8f 5f       	subi	r24, 0xFF	; 255
 ed0:	8c 93       	st	X, r24
	
	LED_REVERSE;
 ed2:	95 b3       	in	r25, 0x15	; 21
 ed4:	81 e0       	ldi	r24, 0x01	; 1
 ed6:	89 27       	eor	r24, r25
 ed8:	85 bb       	out	0x15, r24	; 21
}
 eda:	ff 91       	pop	r31
 edc:	ef 91       	pop	r30
 ede:	bf 91       	pop	r27
 ee0:	af 91       	pop	r26
 ee2:	9f 91       	pop	r25
 ee4:	8f 91       	pop	r24
 ee6:	0f 90       	pop	r0
 ee8:	0f be       	out	0x3f, r0	; 63
 eea:	0f 90       	pop	r0
 eec:	1f 90       	pop	r1
 eee:	18 95       	reti

00000ef0 <__umulhisi3>:
 ef0:	a2 9f       	mul	r26, r18
 ef2:	b0 01       	movw	r22, r0
 ef4:	b3 9f       	mul	r27, r19
 ef6:	c0 01       	movw	r24, r0
 ef8:	a3 9f       	mul	r26, r19
 efa:	70 0d       	add	r23, r0
 efc:	81 1d       	adc	r24, r1
 efe:	11 24       	eor	r1, r1
 f00:	91 1d       	adc	r25, r1
 f02:	b2 9f       	mul	r27, r18
 f04:	70 0d       	add	r23, r0
 f06:	81 1d       	adc	r24, r1
 f08:	11 24       	eor	r1, r1
 f0a:	91 1d       	adc	r25, r1
 f0c:	08 95       	ret

00000f0e <strchr>:
 f0e:	fc 01       	movw	r30, r24
 f10:	81 91       	ld	r24, Z+
 f12:	86 17       	cp	r24, r22
 f14:	21 f0       	breq	.+8      	; 0xf1e <strchr+0x10>
 f16:	88 23       	and	r24, r24
 f18:	d9 f7       	brne	.-10     	; 0xf10 <strchr+0x2>
 f1a:	99 27       	eor	r25, r25
 f1c:	08 95       	ret
 f1e:	31 97       	sbiw	r30, 0x01	; 1
 f20:	cf 01       	movw	r24, r30
 f22:	08 95       	ret

00000f24 <strcpy>:
 f24:	fb 01       	movw	r30, r22
 f26:	dc 01       	movw	r26, r24
 f28:	01 90       	ld	r0, Z+
 f2a:	0d 92       	st	X+, r0
 f2c:	00 20       	and	r0, r0
 f2e:	e1 f7       	brne	.-8      	; 0xf28 <strcpy+0x4>
 f30:	08 95       	ret

00000f32 <strstr>:
 f32:	fb 01       	movw	r30, r22
 f34:	51 91       	ld	r21, Z+
 f36:	55 23       	and	r21, r21
 f38:	a9 f0       	breq	.+42     	; 0xf64 <strstr+0x32>
 f3a:	bf 01       	movw	r22, r30
 f3c:	dc 01       	movw	r26, r24
 f3e:	4d 91       	ld	r20, X+
 f40:	45 17       	cp	r20, r21
 f42:	41 11       	cpse	r20, r1
 f44:	e1 f7       	brne	.-8      	; 0xf3e <strstr+0xc>
 f46:	59 f4       	brne	.+22     	; 0xf5e <strstr+0x2c>
 f48:	cd 01       	movw	r24, r26
 f4a:	01 90       	ld	r0, Z+
 f4c:	00 20       	and	r0, r0
 f4e:	49 f0       	breq	.+18     	; 0xf62 <strstr+0x30>
 f50:	4d 91       	ld	r20, X+
 f52:	40 15       	cp	r20, r0
 f54:	41 11       	cpse	r20, r1
 f56:	c9 f3       	breq	.-14     	; 0xf4a <strstr+0x18>
 f58:	fb 01       	movw	r30, r22
 f5a:	41 11       	cpse	r20, r1
 f5c:	ef cf       	rjmp	.-34     	; 0xf3c <strstr+0xa>
 f5e:	81 e0       	ldi	r24, 0x01	; 1
 f60:	90 e0       	ldi	r25, 0x00	; 0
 f62:	01 97       	sbiw	r24, 0x01	; 1
 f64:	08 95       	ret

00000f66 <_exit>:
 f66:	f8 94       	cli

00000f68 <__stop_program>:
 f68:	ff cf       	rjmp	.-2      	; 0xf68 <__stop_program>
